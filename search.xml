<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anaconda+VSCode配置Python开发学习环境</title>
    <url>/2020/12/15/Anaconda-VSCode%E9%85%8D%E7%BD%AEPython%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当前，流行语很多，其中“大数据”、“人工智能”、“信息化”、“教育信息化”备受关注，而其核心的工具大多都指向了 <strong>Python</strong>者们程序设计语言，不论是生产环境的开发，还是关乎国计民生的 <strong>教育</strong>，都在向它倾斜。近几年来，教育主管部门更是发布了重磅的政策性的指导意见，可见从事教育的一线工作者掌握这门语言是多么的迫在眉睫，它不仅能提高自身的工作效率，更能在其职业的高度上认识信息社会发展的契机和理论认识，进而引领学习者开阔视野，能够适应当今社会发展，能够对社会发展激发出更加活跃的创造力。本文从一个最最基础的角度，聊一聊 <strong>Python</strong> 学习、开发环境的配置，但更多的偏重于搭建 <strong>Python</strong> 学习环境。</p>
<span id="more"></span>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><strong>Python</strong>，关于其的信息铺天盖地，培训机构、学习网站充斥了互联网各个角落。<strong>Python</strong> 中文名是蟒蛇。<strong>Python</strong>的创始人为荷兰人吉多·范·罗苏姆（Guido van Rossum）。1989年圣诞节期间，在阿姆斯特丹，为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中 <strong>Python</strong>（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森的飞行马戏团》（Monty Python’s Flying Circus）。</p>
<p><strong>Python</strong> 是一种解释型脚本语言，可以应用于以下领域 Web 和 网络开发、 科学计算和统计、 人工智能、 桌面界面开发、 软件开发、 网络爬虫、 黑客最喜欢的语言。</p>
<p><strong>Python</strong> 的主要运用领域有:</p>
<p>云计算：云计算最热的语言，典型的应用OpenStack</p>
<p>WEB开发：许多优秀的WEB框架，许多大型网站是Python开发、YouTube、Dropbox、Douban……典型的Web框架包括Django</p>
<p>科学计算和人工智能：典型的图书馆 NumPy、SciPy、Matplotlib、Enided 图书馆、熊猫</p>
<p>系统操作和维护：操作和维护人员的基本语言</p>
<p>金融：定量交易、金融分析，在金融工程领域，Python不仅使用最多，而且使用最多，其重要性逐年增加。</p>
<p>图形 GUI：PyQT，WXPython，TkInter</p>
<p><strong>Python</strong> 在一些公司的运用有:</p>
<p>谷歌：谷歌应用程序引擎，代码。Google.com、 Google 爬虫、Google 广告和其他项目正在广泛使用 <strong>Python</strong>。</p>
<p>CIA：美国中情局网站是用 <strong>Python</strong> 开发的。</p>
<p>NASA：美国航天局广泛使用 <strong>Python</strong> 进行数据分析和计算。</p>
<p>YouTube：世界上最大的视频网站 YouTube 是用 <strong>Python</strong> 开发的。</p>
<p>Dropbox：美国最大的在线云存储网站，全部用 <strong>Python</strong> 实现，每天处理 10 亿的文件上传和下载。</p>
<p>Instagram：美国最大的照片共享社交网站，每天有 3000 多万张照片被共享，所有这些都是用 <strong>Python</strong> 开发的。</p>
<p>Facebook：大量的基本库是通过 <strong>Python</strong> 实现的</p>
<p>Red Hat&#x2F;Centos：世界上最流行的 Linux 发行版中的 Yum 包管理工具是用 <strong>Python</strong> 开发的</p>
<p>Douban：几乎所有公司的业务都是通过 <strong>Python</strong> 开发的。</p>
<p>知乎：中国最大的 Q＆A 社区，通过 <strong>Python</strong> 开发（国外 Quora）</p>
<p>除此之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝、土豆、新浪、果壳等公司正在使用 <strong>Python</strong> 来完成各种任务。</p>
<p>信息化时代的应用真是太多太多了，不仅 <strong>Python</strong> 能做到，其他的程序语言也可以做到，只是为什么选择它？我们从 <strong>Python</strong>之禅中可以获得一些答案吧：<br>    Beautiful is better than ugly.<br>    优美胜于丑陋（Python以编写优美的代码为目标）<br>    Explicit is better than implicit.<br>    明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>    Simple is better than complex.<br>    简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>    Complex is better than complicated.<br>    复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>    Flat is better than nested.<br>    扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>    Sparse is better than dense.<br>    间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）<br>    Readability counts.<br>    可读性很重要（优美的代码是可读的）<br>    Special cases aren’t special enough to break the rules.<br>    Although practicality beats purity.<br>    即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）<br>    Errors should never pass silently.<br>    Unless explicitly silenced.<br>    不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）<br>    In the face of ambiguity, refuse the temptation to guess.<br>    当存在多种可能，不要尝试去猜测<br>    There should be one– and preferably only one –obvious way to do it.<br>    而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>    Although that way may not be obvious at first unless you’re Dutch.<br>    虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）<br>    Now is better than never.<br>    Although never is often better than <em>right</em> now.<br>    做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）<br>    If the implementation is hard to explain, it’s a bad idea.<br>    If the implementation is easy to explain, it may be a good idea.<br>    如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）<br>    Namespaces are one honking great idea – let’s do more of those!<br>    命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</p>
<p>学习<strong>Python</strong> <a href="https://www.python.org/">官网</a> 是一个能找到不错文档的地方，同样也能找到搭建 <strong>Python</strong> 环境的核心<a href="https://www.python.org/downloads/">安装文件</a>,但是仅仅依靠其远不能达到要求，这个时候就需要加载一些第三方的应用（模块），其中之一就是 <strong>Anaconda</strong> 。</p>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p><strong>Anaconda</strong>，水蚺(南美洲蟒蛇)，和蟒蛇是同类吧，就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了 <strong>conda、Python</strong> 在内的超过180个科学包及其依赖项。昂，原来 <strong>Anaconda</strong> 是一个 <strong>Python</strong> 的大管家啊！</p>
<h2 id="Windows系统下的安装操作"><a href="#Windows系统下的安装操作" class="headerlink" title="Windows系统下的安装操作"></a>Windows系统下的安装操作</h2><p>由于某种原因， <strong>Anaconda</strong> 的官网我们无法访问，文档也需要从其他第三方的网站去查询，幸好我们国内有网站提供了其镜像的下载，经常用的速度比较快的<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华镜像站下载</a>，此镜像站提供了适用多平台的安装包，感觉还是下载最新版本吧，如果你用的是Windows平台，那么就在这里下载 <em>Anaconda3-5.3.1-Windows-x86.exe</em> 或者 <em>Anaconda3-5.3.1-Windows-x86_64.exe</em> 吧，区别是前一个适合32位操作系统平台，后一个适合64位操作系统平台，至今感觉后一种比较普遍了。若是在Linux平台安装，在后面会详细介绍。</p>
<p>那就双击下载下来的安装文件进行安装吧，安装非常简单，一直下一步（next）默认安装就可以了，只是这个软件包含的应用众多，体量比较大，所用时间比较长，等等就好啦。给一张安装界面吧：<br>    <img src="https://img-blog.csdnimg.cn/20201216101019919.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="Anaconda安装"><br>安装完成就可以在系统开始菜单里找到 <strong>Anaconda</strong> 的应用程序了，如图：<br>    <img src="https://img-blog.csdnimg.cn/20201216101631215.png#pic_center" alt="Anaconda程序菜单"></p>
<p>嗯，我们找到 <strong>Anaconda Promot</strong> 利用右键单击选择 <code>以管理员身份运行</code>,<br>    <img src="https://img-blog.csdnimg.cn/20201216102530638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda promot启动"><br>你就会看到 <strong>CMD</strong> 窗口<br>    <img src="https://img-blog.csdnimg.cn/20201216102623819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda操作界面"><br>接下来键入 <code>conda --help</code>，显示 <strong>Anaconda</strong> 管理 <strong>Python</strong> 应用模块的命令提示信息。<br>    <img src="https://img-blog.csdnimg.cn/20201216103244327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda帮助"><br>常用的同步更新软件包（update）、安装软件包（install）。不管是更新还是安装，都需要到软件官网去获取软件信息，由于某种原因这些操作都是非常困难的，因此需要对软件默认的配置修改成国内的快速镜像地址，这样才能高效。<br>在当前用户的根目录下创建 <code>.condarc</code> 文件，因为在 Windows系统下无法创建以”.”开头的文件，因此需要利用命令行进项操作，让其生成 <code>.condarc</code> 文件，然后利用文本编辑软件打开，编辑如下内容后保存退出。<br>    <img src="https://img-blog.csdnimg.cn/20201216110459956.png#pic_center" alt=".condarc文件生成"><br>    <img src="https://img-blog.csdnimg.cn/20201216111056674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt=".condarc文件位置"><br>    <img src="https://img-blog.csdnimg.cn/20201216110509888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt=".condarc文件配置"><br>再利用 <code>conda</code> 命令获取软件的过程中可能会用到 <code>pip</code> 进行一些下载，因此也需要将 <code>pip</code> 配置成国内的快速镜像地址，具体做法是，在当前用户根目录下创建 <code>pip</code> 文件夹，并且在此文件夹内创建 <code>pip.ini</code> 文件，利用文本编辑器编辑如下图内容到此文件后保存退出。<br>    <img src="https://img-blog.csdnimg.cn/20201216111319848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pip配置文件位置"><br>    <img src="https://img-blog.csdnimg.cn/20201216110653435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pip配置文件创建"></p>
<h2 id="Linux系统下的安装"><a href="#Linux系统下的安装" class="headerlink" title="Linux系统下的安装"></a>Linux系统下的安装</h2><p>本文以 Manjaro 操作系统为例配置Anaconda。<br>首先配置更新源， <code>code /etc/pacman.conf</code> 在文档末尾加上两行，配置 <strong>archlinuxcn</strong> 更新源，如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216114847736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pacman.conf配置archlinuxcn"><br>然后执行 <code>sudo pacman -Syy</code> 和 <code>sudo pacman -Syu</code> 进行系统镜像数据库拉取和更新，然后安装 <strong>archlinuxcn</strong> KEY, <code>sudo pacman -S archlinuxcn-keyring</code> ，如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216120110837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="archlinux-keyring安装"><br>接下来就开始安装 <strong>Anaconda</strong> 了， <code>sudo pacman -S anaconda</code> ,输入“y”，进行安装，一路回车，遇到选“yes”还是“no”的时输入“yes”，然后回车即可，在这里就不截图了。一壶茶过后就可以了。<br>    <img src="https://img-blog.csdnimg.cn/20201216120626439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="anaconda安装"><br>然后配置更新镜像源，跟 Windows 一样在 当前用户的根目录下 <code>/home/eric/.condarc</code>, <strong>pip</strong> 镜像配置文件需要利用命令： <code>mkdir -p /home/eric/.pip</code> <code>touch /home/eric/.pip/pip.conf</code> 创建。然后通过命令 <code>code /home/eric/.condarc </code> 和 <code>code /home/eric/.pip/pip.conf</code> 分别打开这两个文件将在本文 Windows部分提及的内容编辑进文件保存退出就OK了（不提供截图了）。<br>Linux下启动 <strong>Anaconda</strong> 如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216122739617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="anaconda启动"><br>接下来的操作和在Windows下操作无异，祝好运吧。</p>
<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。该编辑器支持多种语言和文件格式的编写，截止2019年9月，已经支持了如下37种语言或文件：F#、HandleBars、Markdown、Python、Java、PHP、Haxe、Ruby、Sass、Rust、PowerShell、Groovy、R、Makefile、HTML、JSON、TypeScript、Batch、Visual Basic、Swift、Less、SQL、XML、Lua、Go、C++、Ini、Razor、Clojure、C#、Objective-C、CSS、JavaScript、Perl、Coffee Script、Dockerfile。</p>
<p>到被誉为神级编辑器的<a href="https://code.visualstudio.com/">VSCode下载地址</a>下载对应平台的源码包或二进制安装文件安装即可，关于其中的操作可以到其官网查阅文档，这里不做赘述了。</p>
<p>好啦，下面就来更新一下你的大水蚺吧！！<br>若有新的应用，那就依照前面所述 <code>conda install xxx</code> 吧，接下来你就在 <strong>Python</strong> 的海洋里遨游吧。</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Python</tag>
        <tag>VSCode</tag>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda3无安装源安装</title>
    <url>/2021/12/06/Anaconda3%E6%97%A0%E5%AE%89%E8%A3%85%E6%BA%90%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="Windows-版本"><a href="#Windows-版本" class="headerlink" title="Windows 版本"></a>Windows 版本</h3><h4 id="清华镜像站下载-Anaconda3"><a href="#清华镜像站下载-Anaconda3" class="headerlink" title="清华镜像站下载 Anaconda3"></a>清华镜像站下载 Anaconda3</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">下载链接</a></p>
<h4 id="上海交通大学镜像站下载-Anaconda3"><a href="#上海交通大学镜像站下载-Anaconda3" class="headerlink" title="上海交通大学镜像站下载 Anaconda3"></a>上海交通大学镜像站下载 Anaconda3</h4><p><a href="https://s3.jcloud.sjtu.edu.cn/899a892efef34b1b944a19981040f55b-oss01/anaconda/miniconda/mirror_clone_list.html">下载链接</a></p>
<h4 id="北京大学开源镜像站下载-Anaconda3"><a href="#北京大学开源镜像站下载-Anaconda3" class="headerlink" title="北京大学开源镜像站下载 Anaconda3"></a>北京大学开源镜像站下载 Anaconda3</h4><p><a href="https://mirrors.pku.edu.cn/anaconda/miniconda/">下载链接</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击下载的 ***.x86_64.exe** 文件（最好是选择最新版本，若需要特殊版本定位支持的 Python 版本即可），一路回车，默认安装，不提使用细节。</p>
<span id="more"></span>

<h3 id="Linux-版本"><a href="#Linux-版本" class="headerlink" title="Linux 版本"></a>Linux 版本</h3><p>在所有的 Linux 发行版都可以利用 curl 直接从官网 (<a href="https://repo.anaconda.com/">https://repo.anaconda.com</a>) 下载，然后利用 <strong>bash</strong> 安装。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code>curl https://repo.anaconda.com/archive/Anaconda3-2022.10-Linux-x86_64.sh --output anaconda3-python-linux.sh
</code></pre>
<p>这里可以访问<a href="https://repo.anaconda.com/archive">官网</a>查看最新版本，然后在利用 <strong>curl</strong> 下载。</p>
<h4 id="bash-安装"><a href="#bash-安装" class="headerlink" title="bash 安装"></a>bash 安装</h4><pre><code>bash anaconda3-python-linux.sh
</code></pre>
<p>根据提示完成目录选择，生成环境变量等选择，完成安装。</p>
<h4 id="环境变量设定"><a href="#环境变量设定" class="headerlink" title="环境变量设定"></a>环境变量设定</h4><pre><code>source ~/.bashrc
</code></pre>
<h4 id="conda-命令操作"><a href="#conda-命令操作" class="headerlink" title="conda 命令操作"></a>conda 命令操作</h4><pre><code>conda update --all -y
conda install conda=&quot;最新版本号&quot; #更新 conda 。
conda create -n &#39;新创建环境名&#39; python=&#39;所需 python 最新版本号&#39; &#39;其他需要的模块,多个利用空格隔开&#39;
conda env list
conda info
conda info list
...
</code></pre>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><p>但使用过程中是需要及时更新 Anaconda3 的，若不小心弄丢 <code>conda</code>，<br>那就需要注意一些操作细节：</p>
<p>若要使用 Anaconda3 的软件包，需要切换进 Anaconda3 ，然后利用 <code>conda</code> 命令进行进行操作，不详说。<br>更新时弄丢 <code>conda</code> 多半是没有切换进 Anaconda3 导致，原因很简单，Linux 发行版自带 Python，将<br>Anaconda3 写入环境变量那就会引起冲突，导致 <code>conda</code> “无地姿容”。因此，但凡进行更新或安装等操作时，<br>需要切换进 Anaconda3 然后再进行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate ENV_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若真的弄丢了 <code>conda</code> 也不要紧，重新安装一下就 OK 了,只是需要加上 <strong>-u</strong> 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash anaconda3-python-linux.sh -u</span><br></pre></td></tr></table></figure>

<p>好了，使用中总结经验，记录下来方便后来人和自己。不当之处，敬请指正。</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch Complete Installation</title>
    <url>/2022/12/07/Arch-Complete-Installation/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>Arch Linux</tag>
        <tag>command line</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现Server-Client</title>
    <url>/2020/12/20/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0Server-Client/</url>
    <content><![CDATA[<p>利用C语言实现客户端浏览器访问服务器和服务器与客户端交互两个场景。</p>
<span id="more"></span>
<h2 id="模拟利用浏览器访问服务器"><a href="#模拟利用浏览器访问服务器" class="headerlink" title="模拟利用浏览器访问服务器"></a>模拟利用浏览器访问服务器</h2><p>代码如下(Server-Browser)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*by GeekBear</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define PORT 8080</span><br><span class="line">//监听的端口号</span><br><span class="line">#define MAX_CONNECT 20</span><br><span class="line">最大连接数</span><br><span class="line">#define BUFFER_SIZE 1024*32</span><br><span class="line">//32k缓冲区满足绝大多数网页请求</span><br><span class="line">#define NAME_BUFFER_SIZE 1024</span><br><span class="line">//路径缓冲 </span><br><span class="line">#define HTTP_END &quot;\r\n\r\n&quot;</span><br><span class="line">//http协议头以两个回车换行结尾</span><br><span class="line">#define BASE_DIR &quot;./100_www/&quot;</span><br><span class="line">//服务器根目录设为当前程序运行路径</span><br><span class="line">#define DEFAULT_PAGE &quot;/index.html&quot;</span><br><span class="line">//默认页面</span><br><span class="line">#define HTTP_OK &quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span><br><span class="line">//http正常回应</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *doAccept(void * parm);           </span><br><span class="line"></span><br><span class="line">//做协议解析 </span><br><span class="line">static void *doProc(void *data);</span><br><span class="line"></span><br><span class="line">int writeFile(int fd,char *filePath);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    printf(&quot;start!\n&quot;);</span><br><span class="line">    printf(&quot;按回车键退出!\n&quot;);</span><br><span class="line">    bzero(&amp;thread,sizeof(thread));</span><br><span class="line">    pthread_create(&amp;thread,NULL,doAccept,NULL);</span><br><span class="line">    getchar();</span><br><span class="line">    printf(&quot;end!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void *doAccept(void * parm)</span><br><span class="line">&#123;</span><br><span class="line">    int socketfd,connectfd;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">    pthread_t pthread;</span><br><span class="line">    signal(SIGCHLD,SIG_IGN);</span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    socketfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if(socketfd == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;serverAddr,sizeof(serverAddr));</span><br><span class="line">        serverAddr.sin_family=AF_INET;</span><br><span class="line">        serverAddr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">        serverAddr.sin_port = htons(PORT);</span><br><span class="line">        if( -1==bind(socketfd,(struct sockaddr*)&amp;serverAddr,sizeof(struct sockaddr)) )</span><br><span class="line">        &#123;</span><br><span class="line">            //FIXME 绑定端口失败时发生段错误！ </span><br><span class="line">            printf(&quot;绑定端口失败！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口成功！\n&quot;);</span><br><span class="line">            if(-1==listen(socketfd,MAX_CONNECT))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听失败！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听成功！\n&quot;);</span><br><span class="line">                printf(&quot;在浏览器中输入http://127.0.0.1:%d来访问本服务器\n&quot;,PORT);</span><br><span class="line">                while(1)</span><br><span class="line">                &#123;</span><br><span class="line">                    //sleep(1);</span><br><span class="line">                    socklen_t socketLen=0;</span><br><span class="line">                    connectfd = accept(socketfd,(struct sockaddr*)&amp;serverAddr,&amp;socketLen);</span><br><span class="line">                    if(connectfd&lt;=0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接失败！\n&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接成功！\n&quot;);</span><br><span class="line">                        bzero(&amp;thread,sizeof(thread));</span><br><span class="line">                        pthread_create(&amp;thread,NULL,doProc,(void*)(intptr_t)connectfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//做协议解析 </span><br><span class="line">static void *doProc(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    int connectfd = (int)(intptr_t)data;</span><br><span class="line">    char *buffer = (char *)malloc(BUFFER_SIZE+1);</span><br><span class="line">    if(buffer==NULL)</span><br><span class="line">        printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">    int readLen=read(connectfd,buffer,BUFFER_SIZE);</span><br><span class="line">    if(readLen&lt;=0)</span><br><span class="line">        goto END;</span><br><span class="line">    buffer[readLen]=0;</span><br><span class="line">    //printf(&quot;%s&quot;,buffer);</span><br><span class="line">    int endLen = strlen(HTTP_END);</span><br><span class="line">    if( (readLen&gt;=endLen) &amp;&amp; (strcmp(buffer+readLen-endLen,HTTP_END)==0) )</span><br><span class="line">    &#123;//是http协议</span><br><span class="line">        printf(&quot;%s&quot;,buffer);</span><br><span class="line">        char *startPos=strstr(buffer,&quot;GET &quot;);</span><br><span class="line">        </span><br><span class="line">        if(startPos!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            startPos+=4;</span><br><span class="line">            char *endPos=strstr(startPos,&quot; &quot;);</span><br><span class="line">            if(endPos!=NULL&amp;&amp;(endPos-startPos)&lt;NAME_BUFFER_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                char *nameBuffer=malloc(NAME_BUFFER_SIZE+1);</span><br><span class="line">                if(nameBuffer==NULL)</span><br><span class="line">                    printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">                nameBuffer[0]=0;</span><br><span class="line">                strcat(nameBuffer,BASE_DIR);</span><br><span class="line">                strncat(nameBuffer,startPos,endPos-startPos);</span><br><span class="line">                if(nameBuffer[strlen(nameBuffer)-1]==&#x27;/&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;is_dir,use default page.\n&quot;);</span><br><span class="line">                    strcat(nameBuffer,DEFAULT_PAGE);</span><br><span class="line">                &#125;</span><br><span class="line">                /*</span><br><span class="line">                //判断路径是否为文件夹，不安全 </span><br><span class="line">                struct stat st;</span><br><span class="line">                stat(nameBuffer,&amp;st);</span><br><span class="line">                if (S_ISDIR(st.st_mode))</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;is_dir,use default page.\n&quot;);</span><br><span class="line">                    strcat(nameBuffer,DEFAULT_PAGE);</span><br><span class="line">                &#125;*/</span><br><span class="line">                printf(&quot;GET:%s\n&quot;,nameBuffer);</span><br><span class="line">                writeFile(connectfd,nameBuffer);</span><br><span class="line">                free(nameBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">END:</span><br><span class="line">    //printf(&quot;end doProc\n&quot;);</span><br><span class="line">    free(buffer);</span><br><span class="line">    close(connectfd);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int writeFile(int fd,char *filePath)</span><br><span class="line">&#123;</span><br><span class="line">    //printf(&quot;write file:%s\n&quot;,filePath);</span><br><span class="line">    int fileHandler=open(filePath,0,O_RDONLY);</span><br><span class="line">    if(fileHandler&lt;=0)</span><br><span class="line">        return -1;</span><br><span class="line">    char *buffer=(char *)malloc(BUFFER_SIZE+1);</span><br><span class="line">    if(buffer==NULL)</span><br><span class="line">        printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">    write(fd,HTTP_OK,strlen(HTTP_OK));</span><br><span class="line">    int readLen=0;</span><br><span class="line">    while( 0&lt;(readLen=read(fileHandler,buffer,BUFFER_SIZE)) )</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd,buffer,readLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer);</span><br><span class="line">    close(fileHandler);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码存储为server-browser.c，利用VSCode或命令行（<strong>gcc server-broser.c -o hostt.exe</strong>)进行编译生成可执行文件，Windows下为hostt.exe，打开系统下的命令提示符 <em>cmd</em> 将目录切换到程序所在目录，键入 <em>hostt.exe</em> 回车执行在窗口显示如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213579.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser1"></p>
<p>然后打开浏览器按照提示信息将<em><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></em>复制到浏览器的地址栏里访问，这时命令提示符窗口就会有反馈信息输出，代表模拟成功，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213655.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser3"></p>
<h2 id="模拟客户端与服务端进行交互"><a href="#模拟客户端与服务端进行交互" class="headerlink" title="模拟客户端与服务端进行交互"></a>模拟客户端与服务端进行交互</h2><p>首先创建服务端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*by GeekBear</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PORT 8090</span><br><span class="line">//监听的端口号</span><br><span class="line">#define MAX_CONNECT 20</span><br><span class="line">//最大连接数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char readBuffer[101];</span><br><span class="line">    char writeBuffer[201];</span><br><span class="line">    int socketfd,connectfd;</span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    //屏蔽管道破解信号，一般服务器都会屏蔽这个型号 </span><br><span class="line">    socketfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    //创建套接字 </span><br><span class="line">    if(socketfd == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;serverAddr,sizeof(serverAddr));</span><br><span class="line">        //相当于memset</span><br><span class="line">        serverAddr.sin_family=AF_INET;</span><br><span class="line">        //ipv4</span><br><span class="line">        serverAddr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">        //设定监听的地址为任何地址都监听</span><br><span class="line">        serverAddr.sin_port = htons(PORT);</span><br><span class="line">        //设置端口号</span><br><span class="line">        //套接字与端口和地址绑定</span><br><span class="line">        if( -1==bind(socketfd,(struct sockaddr*)&amp;serverAddr,sizeof(struct sockaddr)) )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口失败！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口成功！\n&quot;);</span><br><span class="line">            //创建监听</span><br><span class="line">            if(-1==listen(socketfd,MAX_CONNECT))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听失败！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听成功！\n&quot;);</span><br><span class="line">                printf(&quot;地址:127.0.0.1:%d\n&quot;,PORT);</span><br><span class="line">                while(1)</span><br><span class="line">                &#123;</span><br><span class="line">                    //sleep(1);</span><br><span class="line">                    socklen_t socketLen=0;</span><br><span class="line">                    //等待客户端的连接到达 </span><br><span class="line">                    connectfd = accept(socketfd,(struct sockaddr*)&amp;serverAddr,&amp;socketLen);</span><br><span class="line">                    if(connectfd&lt;=0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接失败！\n&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接成功！\n&quot;);</span><br><span class="line">                        //接收数据 </span><br><span class="line">                        int readLength=read(connectfd,readBuffer,100);</span><br><span class="line">                        if(readLength&gt;0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            readBuffer[readLength]=0;</span><br><span class="line">                            printf(&quot;收到消息:%s,长度:%d\n&quot;,readBuffer,readLength);</span><br><span class="line">                            sprintf(writeBuffer,&quot;received your msg:&#x27;%s&#x27;\n&quot;,readBuffer);</span><br><span class="line">                            //发送数据</span><br><span class="line">                            write(connectfd,writeBuffer,strlen(writeBuffer));</span><br><span class="line">                        &#125;</span><br><span class="line">                        //关闭与客户端的连接</span><br><span class="line">                        close(connectfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //FIXME 关闭套接字不知道是不是这个方法，反正感觉关闭失败了  </span><br><span class="line">        close(socketfd);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;程序结束\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建客户端程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*by GeekBear</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char readBuffer[101];</span><br><span class="line">    char writeBuffer[201];</span><br><span class="line">    int connectRet,socketfd;</span><br><span class="line">    struct sockaddr_in clientAddr;</span><br><span class="line">    //signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    //屏蔽管道破解信号，一般服务器都会屏蔽这个型号 </span><br><span class="line">    socketfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    //创建套接字 ,AF_NET:ipv4，SOCK_STREAM:TCP协议 </span><br><span class="line">    if(socketfd == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //return 0;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;clientAddr,sizeof(clientAddr));//相当于memset</span><br><span class="line">        clientAddr.sin_family=AF_INET;//ipv4</span><br><span class="line">        //ip地址:0x7f000001:127.0.0.1</span><br><span class="line">        //0x7f:127</span><br><span class="line">        clientAddr.sin_addr.s_addr=htonl(0x7f000001);</span><br><span class="line">        clientAddr.sin_port = htons(8090);</span><br><span class="line">        //设置端口号</span><br><span class="line">        connectRet=connect(socketfd,(struct sockaddr*)&amp;clientAddr,sizeof(struct sockaddr));</span><br><span class="line">        if(-1==connectRet)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;连接到服务器失败!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;连接到服务器成功!\n&quot;);</span><br><span class="line">            printf(&quot;请输入要发送的消息并回车:&quot;);</span><br><span class="line">            scanf(&quot;%s&quot;,writeBuffer);</span><br><span class="line">            write(socketfd,writeBuffer,strlen(writeBuffer));</span><br><span class="line">            int readLength=read(socketfd,readBuffer,100);</span><br><span class="line">            if(readLength&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                readBuffer[readLength]=0;</span><br><span class="line">                printf(&quot;收到的消息:%s\n&quot;,readBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(socketfd);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;程序结束\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来将两个程序进行编译，分别生成 <em>server.exe</em> 和 <em>client.exe</em> ，分别打开2个命令提示符窗口，在其中一个执行 <em>server.exe</em> 在另一个执行 <em>client.exe</em> ，在执行 <em>client.exe</em>的窗口中输入信息，回车后会在执行服务端程序的窗口显示在 <em>client.exe</em> 窗口中输入的内容，进而实现了模拟服务器端与客户机端的信息交互过程。</p>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213573.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="client"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213520.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive3"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213473.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive4"></p>
<p>是不是很有趣？我觉着很有趣，下一步将用Python来实现一下这个过程，敬请期待。。。</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Server-Client</tag>
        <tag>Server-Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的HelloWorld</title>
    <url>/2021/06/27/C%E8%AF%AD%E8%A8%80%E7%9A%84HelloWorld/</url>
    <content><![CDATA[<p>本渣从 C 语言起步，多年来接触的编程语言也有一些了，数年前开始接触Python，可以说和 C 语言形成一个鲜明的对比了。不管是 Python 还是 C 语言，个有特点，熟悉并适应其规则就好。本渣想说的是“基础”是任何一门语言的重中之重，不能异想天开，想当然，以后有时间也来回顾回顾 C 语言的基础经典，今天就来个世纪经典：Hello C World!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Hello C World!!!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是其中一种形式，还有其他种吗？在评论区贴上来吧！！！来吧，不要以为其简单的不值一提哈，来，加入吧。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Helloworld</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub博客调试中</title>
    <url>/2021/04/11/GitHub%E5%8D%9A%E5%AE%A2%E8%B0%83%E8%AF%95%E4%B8%AD/</url>
    <content><![CDATA[<p>加油啊，让技术无国界，让政治在技术中无所作为。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Basics</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客在多台终端同步管理</title>
    <url>/2020/12/15/Hexo%E5%8D%9A%E5%AE%A2%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Hexo-Github博客在多台终端同步管理"><a href="#Hexo-Github博客在多台终端同步管理" class="headerlink" title="Hexo+Github博客在多台终端同步管理"></a>Hexo+Github博客在多台终端同步管理</h2><p>最近这两天研究Hexo制作个人博客，发现自己放了好长时间的博客系统在一次环境系统升级过后崩溃了，然后决定从零开始。在配置过程中又遇到了这样的问题，在不同的电脑终端同步博客遇到了困难，不能实现要求，然后查找了很多博文和官网的文档，最终找到了解决的办法，在此记录下来以便能帮助有需要的后来人。此方法利用Git管理Hexo产生的文件，实现在不同的电脑上同步（Github）所需的文件，也可以正常的在不同的Hexo环境里进行相应操作，只要在做完之后同步到Github的仓库里即可。下面具体来说说：</p>
<span id="more"></span>

<h2 id="搭建node-js环境"><a href="#搭建node-js环境" class="headerlink" title="搭建node.js环境"></a>搭建node.js环境</h2><h3 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h3><p>官网下载并安装<a href="https://nodejs.org/en/">Nodejs和npm</a>。</p>
<h3 id="Linux环境（本文以Manjaro为例）"><a href="#Linux环境（本文以Manjaro为例）" class="headerlink" title="Linux环境（本文以Manjaro为例）"></a>Linux环境（本文以Manjaro为例）</h3><pre><code>$sudo pacman -S nodejs npm
</code></pre>
<h3 id="配置npm国内镜像源"><a href="#配置npm国内镜像源" class="headerlink" title="配置npm国内镜像源"></a>配置npm国内镜像源</h3><pre><code>$npm config set registry https://registry.npm.taobao.org
</code></pre>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="Windows环境-1"><a href="#Windows环境-1" class="headerlink" title="Windows环境"></a>Windows环境</h3><p>官网下载并安装<a href="https://git-scm.com/download/win">Git</a>。</p>
<h3 id="Linux环境（本文以Manjaro为例）-1"><a href="#Linux环境（本文以Manjaro为例）-1" class="headerlink" title="Linux环境（本文以Manjaro为例）"></a>Linux环境（本文以Manjaro为例）</h3><pre><code>sudo pacman -S git
</code></pre>
<h2 id="安装Hexo（Hexo环境搭建）"><a href="#安装Hexo（Hexo环境搭建）" class="headerlink" title="安装Hexo（Hexo环境搭建）"></a>安装Hexo（Hexo环境搭建）</h2><p>这里不赘述直接给出安装方法（命令）所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo及其相关组件。</p>
<pre><code>$hexo init &lt;Blog-folder&gt;
$cd &lt;Blog-folder&gt;
$npm install
$sudo npm install -g hexo-cli
$npm install hexo --save
$npm install hexo-deployer-git --save
$npm install hexo-generator-feed --save
$npm install hexo-generator-searchdb --save
</code></pre>
<p>新建完成后，指定文件夹<Blog-folder>（文件夹名姑且定为：<strong>Hexo</strong>）的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre>
<p>之后就可以利用 <strong>hexo</strong> 命令进行一些操作，可以参看<a href="https://hexo.io/zh-cn/docs/">Hexo官网文档</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Github-分支管理Hexo环境目录"><a href="#Github-分支管理Hexo环境目录" class="headerlink" title="Github 分支管理Hexo环境目录"></a>Github 分支管理Hexo环境目录</h3><p>方案主要是通过维护两条git分支来实现，第一个分支是 Gihub 上默认的 <strong>master</strong> 分支，用于存放发布的博文的静态页面；另外再新建一个分支，比如命名为 <strong>Hexo</strong> ，通过此分支存放主题、原始的博客文件等等，这些文件才是不同电脑需要同步的文件；当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹下）或者新增博客（在source文件夹下），同步到远程的 <strong>Hexo</strong> 分支，然后在通过 <em>hexo g -d</em>命令发布博文，也就是将新增的博文的静态页面同步到 <strong>master</strong> 分支。这样通过不同的分支管理不同的文件，实现了多台电脑同步更新博文的功能。</p>
<h3 id="Hexo-目录结构"><a href="#Hexo-目录结构" class="headerlink" title="Hexo 目录结构"></a>Hexo 目录结构</h3><p>当执行 <em>hexo g -d</em> 后目录结构发生了变化，如下：</p>
<pre><code>.
├── .gitignore
├── .deploy_git
|   ├── ...
|   ├── ...
|   └── ...
├── node_modules
├── public
├── package-lock.json
├── db.json
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre>
<p>其中 <em>.deploy_git</em>、<em>public</em> 两个文件夹下存放的是博客文章的静态页面，通过对比 Github 上博客仓库的<strong>master</strong>分支可以看到<strong>master</strong>分支下面的文件结构和 <em>.deploy_git</em> 文件夹下的文件是一致的，这个应该可以判断通过 <em>hexo g -d</em> 发布到 Github 的内容就是 <em>.deploy_git</em> 文件夹下面的文件。其余的文件夹和文件即是<strong>Hexo</strong>的主题文件、原始的博客文件等，刚在上文提到的<strong>Hexo</strong>分支，存的就是这些文件。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建分支（在-Github上操作）"><a href="#创建分支（在-Github上操作）" class="headerlink" title="创建分支（在 Github上操作）"></a>创建分支（在 Github上操作）</h3><p>首先在Github上面创建一个分支命名为Hexo，Hexo 是从master 拉取，所以分支的文件和 master 一样。</p>
<h3 id="初始化分支（PC1上面操作）"><a href="#初始化分支（PC1上面操作）" class="headerlink" title="初始化分支（PC1上面操作）"></a>初始化分支（PC1上面操作）</h3><p>在已经部署好Hexo环境的PC1上的安装Hexo的根目录下拉取 Hexo 分支，步骤如下：</p>
<pre><code>git clone 仓库地址 username.github.io
</code></pre>
<p>将仓库文件拉取到本地，生成的文件名为 username.github.io；进入username.github.io文件夹，除了 <em>.git</em> 文件夹以外，其他文件全部删除；</p>
<pre><code>git add .
</code></pre>
<p>将修改提交至暂存区；</p>
<pre><code>git commit -m “提交说明”
</code></pre>
<p>提交本次修改；</p>
<pre><code>git push origin Hexo
</code></pre>
<p>将本次修改推送到远端 Hexo；将刚才未删除的 <em>.git</em> 文件夹拷贝至 <strong>Hexo</strong> 根目录，删除 <em>username.github.io</em> 文件夹，此时本地的 Hexo 目录已与 Github 上面的 Hexo 分支关联了，而且默认的   <em>.gitignore</em> 已经配置了忽略规则，所以已经可以将根目录下的文件同步上去，还是依次调用 <em>git add .</em> 、*git commit -m ‘comment’*、 <em>git push origin Hexo</em> 三个命令将当前的文件推送至远程的 Hexo分支。</p>
<h3 id="同步分支（PC2上面操作）"><a href="#同步分支（PC2上面操作）" class="headerlink" title="同步分支（PC2上面操作）"></a>同步分支（PC2上面操作）</h3><p>此时在PC2上，创建文件夹Blog，在Blog文件夹下面还行以下操作：</p>
<pre><code>git clone 仓库地址 BlogName
git clone -b Hexo 仓库地址 hexo.repo
</code></pre>
<p>在clone下来的仓库文件夹中将 <em>hexo.repo</em> 文件夹下的文件拷贝到 <em>BlogName</em> 目录中，然后安装和配置hexo环境，依次调用命令： </p>
<pre><code>$npm install
$sudo npm install -g hexo-cli
$npm install hexo --save
$npm install hexo-deployer-git --save
$npm install hexo-generator-feed --save
$npm install hexo-generator-searchdb --save
</code></pre>
<p>（不需要<em>hexo init</em>）此时通过命令 </p>
<pre><code>hexo g
hexo s 
</code></pre>
<p>即可在本地开启同步下来的博客静态页面，并通过 <em><a href="http://localhost:4000/">http://localhost:4000/</a></em> 访问。</p>
<h3 id="发布博文（PC1或者PC2）"><a href="#发布博文（PC1或者PC2）" class="headerlink" title="发布博文（PC1或者PC2）"></a>发布博文（PC1或者PC2）</h3><p>后续不管是PC1还是PC2，如果修改了主题或者新增博文，按照以下步骤即可：</p>
<pre><code>#修改主题

git add .
git commit -m “修改说明”
git push origin Hexo

#新增博文

hexo g -d
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>技术研究是在反复咀嚼的过程中提高的，伴随着咀嚼的过程时常会感到一丝丝的甜美无比的感觉，走在技术研究路上的渣渣们，加油！！</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nodejs</tag>
        <tag>Git</tag>
        <tag>Markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HangInThere</title>
    <url>/2020/12/19/HangInThere/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201219000658706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201219000658664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201219000658660.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="3"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>HangInThere</tag>
      </tags>
  </entry>
  <entry>
    <title>MSYS2配置总结（恢复）</title>
    <url>/2020/04/11/MSYS2%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93-2020-04-11/</url>
    <content><![CDATA[<p><a href="http://www.msys2.org/">MSYS2下载：</a><br>MSYS2是什么？MSYS2 （Minimal SYStem 2） 是一个MSYS的独立改写版本，主要用于 shell 命令行开发环境。同时它也是一个在Cygwin （POSIX 兼容性层） 和 MinGW-w64（从”MinGW-生成”）基础上产生的，追求更好的互操作性的 Windows 软件。MSYS2 是MSYS的一个升级版,准确的说是集成了pacman和Mingw-w64的Cygwin升级版, 提供了bash shell等linux环境、版本控制软件（git&#x2F;hg）和MinGW-w64 工具链。与MSYS最大的区别是移植了 Arch Linux的软件包管理系统 Pacman(其实是与Cygwin的区别)。</p>
<span id="more"></span>

<p>特点:</p>
<pre><code>* 安装方便,自带 pacman 管理，可以使用 pkgtool 来 makepkg,较快的源速度（可以修改源地址）,自带软件和库较全而且比较新,使用mingw-w64工具链,可以编译32位或64位代码（需要自行安装）,中文支持好,可以直接输入和浏览中文目录。 *
</code></pre>
<h3 id="MSYS2的MirrorList配置"><a href="#MSYS2的MirrorList配置" class="headerlink" title="MSYS2的MirrorList配置"></a>MSYS2的MirrorList配置</h3><p>1、修改msys2安装目录下的&#x2F;etc&#x2F;pacman.d文件夹里面的3个mirrorlist.*文件</p>
<p><code>[mirrorlist.mingw32]</code><br><code>#中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/</code><br><code>#北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/i686</code><br><code>#清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/i686</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MINGW/i686</code><br><code>Include = /etc/pacman.d/mirrorlist.mingw32</code></p>
<p><code>[mirrorlist.mingw64]</code><br><code>#中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/</code><br><code>#北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/x86_64</code><br><code>清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/x86_64</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MINGW/x86_64</code><br><code>Include = /etc/pacman.d/mirrorlist.mingw64</code></p>
<p><code>[mirrorlist.msys]</code><br><code>中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch</code><br><code>北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MSYS2/$arch</code><br><code>清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MSYS2/$arch</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MSYS2/$arch</code><br><code>Include = /etc/pacman.d/mirrorlist.msys</code></p>
<p>2、修改&#x2F;etc&#x2F;pacman.conf，把下面注释行取消注释</p>
<p><code>XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u</code></p>
<p>3、更新软件包</p>
<p><code>pacman -Syu</code></p>
<h3 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h3><p>1、查看工具套件</p>
<p><code>pacman -Sg</code></p>
<p>得到结果如下：</p>
<p><code>kf5</code><br><code>mingw-w64-i686-toolchain</code><br><code>mingw-w64-i686</code><br><code>mingw-w64-i686-gimp-plugins</code><br><code>mingw-w64-i686-qt4</code><br><code>mingw-w64-i686-qt</code><br><code>mingw-w64-i686-qt5</code><br><code>mingw-w64-i686-vulkan-devel</code><br><code>tesseract-data</code><br><code>mingw-w64-x86_64-toolchain</code><br><code>mingw-w64-x86_64</code><br><code>mingw-w64-x86_64-gimp-plugins</code><br><code>mingw-w64-x86_64-qt4</code><br><code>mingw-w64-x86_64-qt</code><br><code>mingw-w64-x86_64-qt5</code><br><code>mingw-w64-x86_64-vulkan-devel</code><br><code>libraries</code><br><code>development</code><br><code>base-devel</code><br><code>base</code><br><code>msys2-devel</code><br><code>compression</code><br><code>VCS</code><br><code>sys-utils</code><br><code>Database</code><br><code>net-utils</code><br><code>editors</code><br><code>python-modules</code><br><code>mingw-w64-cross-toolchain</code><br><code>mingw-w64-cross</code><br><code>MSYS2-devel</code><br><code>perl-modules</code></p>
<p>自行根据需要安装，一般较常用安装</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-toolchain libraries development base-devel msys2-devel compression VCS</code></p>
<p><code>sys-utils net-utils editors python-modules</code></p>
<p><code>pacman -S --noconfirm mingw-w64-cross mingw-w64-cross-toolchain</code></p>
<p>2、常用工具</p>
<p>查看可安装软件列表</p>
<p><code>pacman -Sl</code></p>
<p>安装python</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-python2 mingw-w64-x86_64-python2-setuptools mingw-w64-x86_64-python2-pip mingw-w64-x86_64-python2-ipython</code><br><code>pacman -S --noconfirm mingw-w64-x86_64-python3 mingw-w64-x86_64-python3-setuptools mingw-w64-x86_64-python3-pip mingw-w64-x86_64-python3-ipython</code></p>
<p>安装python科学计算库</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-python2-numpy mingw-w64-x86_64-python2-scipy mingw-w64-x86_64-python2-matplotlib mingw-w64-x86_64-python2-pandas</code><br><code>pacman -S --noconfirm mingw-w64-x86_64-python3-numpy mingw-w64-x86_64-python3-scipy mingw-w64-x86_64-python3-matplotlib mingw-w64-x86_64-python3-pandas</code></p>
<p>安装所有python工具</p>
<p><code>pacman -Sl | grep mingw-w64-x86_64-python2 | awk &#39;&#123;print &quot;pacman -S --noconfirm &quot;$2&#125;&#39; &gt; python2-all.sh</code><br><code>sh python2-all.sh</code><br><code>pacman -Sl | grep mingw-w64-x86_64-python3 | awk &#39;&#123;print &quot;pacman -S --noconfirm &quot;$2&#125;&#39; &gt; python3-all.sh</code><br><code>sh python3-all.sh</code></p>
<p>安装nodejs(nodejs的安装貌似还有些问题）</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-nodejs</code></p>
<p>安装帮助手册</p>
<p><code>pacman -S --noconfirm help2man man-db man-pages-posix</code></p>
<p>安装zsh和git</p>
<p><code>pacman -S --noconfirm zsh git</code></p>
<p>安装oh my zsh（此网站貌似已经废弃）</p>
<p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p>
<p>启动打开zsh</p>
<p><code>vim .bashrc</code></p>
<p>在文件最后一行添加，当然也可以直接在命令行中执行</p>
<p><code>exec zsh</code><br>安装vim</p>
<p><code>pacman -S --noconfirm vim</code></p>
<p>超强vim配置文件（此网站也貌似飞向了月球）</p>
<p><code>wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x</code></p>
<h3 id="Pacman-命令详解"><a href="#Pacman-命令详解" class="headerlink" title="Pacman 命令详解"></a>Pacman 命令详解</h3><p>Pacman 是一个命令行工具，这意味着当你执行下面的命令时，必须在终端或控制台中进行。</p>
<p>1、更新系统</p>
<p>在 Arch Linux 中，使用一条命令即可对整个系统进行更新：</p>
<p><code>pacman -Syu</code></p>
<p>如果你已经使用 <code>pacman -Sy</code> 将本地的包数据库与远程的仓库进行了同步，也可以只执行：</p>
<p><code>pacman -Su</code></p>
<p>2、安装包</p>
<p><code>pacman -S 包名</code> 例如，执行 <code>pacman -S firefox</code> 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。<br><code>pacman -Sy 包名</code> 与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br><code>pacman -Sv 包名</code> 在显示一些操作信息后执行安装。<br><code>pacman -U 安装本地包</code>，其扩展名为 <code>pkg.tar.gz</code><br>。<br>3、删除包</p>
<p><code>pacman -R 包名</code> 该命令将只删除包，不包含该包的依赖。<br><code>pacman -Rs 包名</code> 在删除包的同时，也将删除其依赖。<br><code>pacman -Rd 包名</code> 在删除包时不检查依赖。</p>
<p>4、搜索包</p>
<p><code>pacman -Ss 关键字</code> 这将搜索含关键字的包。<br><code>pacman -Qi 包名</code> 查看有关包的信息。<br><code>pacman -Ql 包名</code> 列出该包的文件。</p>
<p>5、其他用法</p>
<p><code>pacman -Sw 包名</code> 只下载包，不安装。<br><code>pacman -Sc</code> Pacman 下载的包文件位于 &#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F; 目录。该命令将清理未安装的包文件。<br><code>pacman -Scc</code> 清理所有的缓存文件。</p>
<p>关于 Pacman 更加详细的用法，可以阅读Pacman 的手册页。</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MSYS2</tag>
        <tag>Python3</tag>
        <tag>MarkdownPro2</tag>
      </tags>
  </entry>
  <entry>
    <title>PS去除图片上的文字</title>
    <url>/2020/12/18/PS%E5%8E%BB%E9%99%A4%E5%9B%BE%E7%89%87%E4%B8%8A%E7%9A%84%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<p>研究操作系统原理未必不需要Photoshop处理图片，碎片化的记录一下吧，也是当做练练文笔了。今天研究H神的时候做一个博文的logo时，需要一张图片，从网上找到了一张图片，发现有网站的水印logo，要去掉它，操作如下：</p>
<span id="more"></span>
<p>看图操作吧，打开要编辑的图片，右上角有 <em>7788.com</em> 水印，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="open"></p>
<p>点选 <strong>选择工具</strong>，将水印框选，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218091628681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="select"></p>
<p>然后选择 <strong>编辑</strong> 菜单中的 <strong>填充</strong>命令，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="fill"></p>
<p>在弹出的 <strong>填充</strong> 对话框 <strong>内容</strong> 选项中选择 <strong>内容识别</strong>，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="identify1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="identify2"></p>
<p>然后点击 <strong>确定</strong>，就把水印去掉啦！</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="complete"></p>
]]></content>
      <categories>
        <category>操作技巧</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础小酌</title>
    <url>/2021/06/27/Python%E5%9F%BA%E7%A1%80%E5%B0%8F%E9%85%8C/</url>
    <content><![CDATA[<p>Python 变量存储很有意思。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=(&quot;p&quot;*2)*3</span><br><span class="line">b=(&quot;p&quot;*3)*2</span><br><span class="line">print(a==b)</span><br></pre></td></tr></table></figure>
<p>以上代码输出什么呢？</p>
<p>欢迎在评论区回复答案。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础知识“切片”回顾</title>
    <url>/2021/06/26/Python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%9C%E5%88%87%E7%89%87%E2%80%9D%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>好久没来写写了，写写python的基础–运算符，回顾也好巩固也好，还是需要注重基础的。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a,b,c=20,5,4</span><br><span class="line">print(a-a*b/a//c)</span><br></pre></td></tr></table></figure>
<p>以上代码快输出结果是什么？</p>
<p>请在评论区给出结果进行评论。<br>具体做法是不是不用我在说拉呢？<br>直接点击博文主题下方的“valine”，或者点击博文标题，在文末位置就会看到啦！！！<br>哈哈哈，快来参与吧。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现Server-Client</title>
    <url>/2020/12/20/Python%E5%AE%9E%E7%8E%B0Server-Client/</url>
    <content><![CDATA[<p>为了尽快的把上一篇提出的问题展示出来，翻看了Python的文档，然后实现一番，果然在代码量上远远少于C语言，更加的形象，判若一个chat！好吧，附上代码和实验截图，一睹为快吧！</p>
<span id="more"></span>

<h2 id="实现浏览器访问服务器"><a href="#实现浏览器访问服务器" class="headerlink" title="实现浏览器访问服务器"></a>实现浏览器访问服务器</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from http.server import BaseHTTPRequestHandler,HTTPServer</span><br><span class="line"></span><br><span class="line">class RequestHandler(BaseHTTPRequestHandler):</span><br><span class="line">    # ...页面模板...</span><br><span class="line">    Page = &#x27;&#x27;&#x27;\</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Header&lt;/td&gt;         &lt;td&gt;Value&lt;/td&gt;          &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Date and time&lt;/td&gt;  &lt;td&gt;&#123;date_time&#125;&lt;/td&gt;    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Client host&lt;/td&gt;    &lt;td&gt;&#123;client_host&#125;&lt;/td&gt;  &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Client port&lt;/td&gt;    &lt;td&gt;&#123;client_port&#125;&lt;/td&gt; &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Command&lt;/td&gt;        &lt;td&gt;&#123;command&#125;&lt;/td&gt;      &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Path&lt;/td&gt;           &lt;td&gt;&#123;path&#125;&lt;/td&gt;         &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    def do_GET(self):</span><br><span class="line">        page = self.create_page()</span><br><span class="line">        self.send_content(page)</span><br><span class="line"></span><br><span class="line">    def create_page(self):</span><br><span class="line">        values = &#123;</span><br><span class="line">            &#x27;date_time&#x27;   : self.date_time_string(),</span><br><span class="line">            &#x27;client_host&#x27; : self.client_address[0],</span><br><span class="line">            &#x27;client_port&#x27; : self.client_address[1],</span><br><span class="line">            &#x27;command&#x27;     : self.command,</span><br><span class="line">            &#x27;path&#x27;        : self.path</span><br><span class="line">        &#125;</span><br><span class="line">        page = self.Page.format(**values)</span><br><span class="line">        return page</span><br><span class="line"></span><br><span class="line">    def send_content(self, page):</span><br><span class="line">        self.send_response(200)</span><br><span class="line">        self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;)</span><br><span class="line">        self.send_header(&quot;Content-Length&quot;, str(len(page)))</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(page.encode(&#x27;utf-8&#x27;))</span><br><span class="line">        </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    serverAddress = (&#x27;&#x27;, 8080)</span><br><span class="line">    server = HTTPServer(serverAddress, RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>

<p>在命令提示符窗口执行 <em>python server.py</em> ，然后打开浏览器，地址栏输入 <em><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></em> ，浏览器中显示预先设定的显示内容，同时在命令提示符窗口显示访问成功的信息。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401539.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401474.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="browser"></p>
<h2 id="实现服务器客户端实时交互"><a href="#实现服务器客户端实时交互" class="headerlink" title="实现服务器客户端实时交互"></a>实现服务器客户端实时交互</h2><p>服务端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">serversocket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">host=socket.gethostname()#获取本地主机名</span><br><span class="line">port=9999</span><br><span class="line">#绑定端口号</span><br><span class="line">serversocket.bind((host,port))</span><br><span class="line"></span><br><span class="line">#设置最大连接数</span><br><span class="line">serversocket.listen(5)</span><br><span class="line">while True:</span><br><span class="line">    print(&#x27;服务器启动，监听客户端链接&#x27;)</span><br><span class="line">    clientsocket,addr=serversocket.accept()</span><br><span class="line">    print(&#x27;链接地址：%s&#x27; % str(addr))</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            data=clientsocket.recv(1024)</span><br><span class="line">        except Exception:</span><br><span class="line">            print(&#x27;断开的客户端：&#x27;,addr)</span><br><span class="line">            break</span><br><span class="line">        print(&#x27;客户端发送内容：&#x27;,data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">        reply=input(&#x27;回复：&#x27;).strip()</span><br><span class="line">        if not reply:</span><br><span class="line">            break</span><br><span class="line">        msg=time.strftime(&#x27;%Y-%m-%d %X&#x27;)#获取结构化时间戳</span><br><span class="line">        msg1=&#x27;[%s]:%s&#x27;% (msg,reply)</span><br><span class="line">        clientsocket.send(msg1.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    clientsocket.close()</span><br><span class="line">serversocket.closel()</span><br></pre></td></tr></table></figure>
<p>以 <em>server-t.py</em>保存。</p>
<p>客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">host=socket.gethostname()</span><br><span class="line">port=9999</span><br><span class="line">s.connect((host,port))</span><br><span class="line">while True:</span><br><span class="line">    data= input(&#x27;&gt;&gt;&#x27;).strip()</span><br><span class="line">    if not data:</span><br><span class="line">        break</span><br><span class="line">    s.send(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    msg=s.recv(1024)</span><br><span class="line">    if not msg:</span><br><span class="line">        break</span><br><span class="line">    print(msg.decode(&#x27;utf-8&#x27;))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>以 <em>client-t.py</em> 保存。</p>
<p>分别启动两个文件所在位置的命令提示符，执行 <em>python server-t.py</em>，<em>python client-t.py</em> ，此时两个命令提示符窗口如下图，你可以在两个窗口中分别输入信息然后回车就会发送到对应的交互端，类似于一个chat了！！！挺有意思，要不你也来试试？！:)</p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-t"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401426.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="client-t"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>import</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>The &#39;net use&#39; command in Windows</title>
    <url>/2022/10/09/The-net-use-command-in-Windows-md/</url>
    <content><![CDATA[<h2 id="net-use-command"><a href="#net-use-command" class="headerlink" title="net use command"></a>net use command</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\zeerr&gt;net use /help</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="此命令的语法是"><a href="#此命令的语法是" class="headerlink" title="此命令的语法是:"></a>此命令的语法是:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NET USE</span><br><span class="line">[devicename | *] [\\computername\sharename[\volume] [password | *]]</span><br><span class="line">        [/USER:[domainname\]username]</span><br><span class="line">        [/USER:[dotted domain name\]username]</span><br><span class="line">        [/USER:[username@dotted domain name]</span><br><span class="line">        [/SMARTCARD]</span><br><span class="line">        [/SAVECRED]</span><br><span class="line">        [/REQUIREINTEGRITY]</span><br><span class="line">        [/REQUIREPRIVACY]</span><br><span class="line">        [/WRITETHROUGH]</span><br><span class="line">        [[/DELETE] | [/PERSISTENT:&#123;YES | NO&#125;]]</span><br><span class="line"></span><br><span class="line">NET USE &#123;devicename | *&#125; [password | *] /HOME</span><br><span class="line"></span><br><span class="line">NET USE [/PERSISTENT:&#123;YES | NO&#125;]</span><br><span class="line"></span><br><span class="line">NET USE 将计算机连接到共享资源</span><br><span class="line">或将计算机与共享资源断开连接。使用时如果没有选项，它会列出</span><br><span class="line">计算机的连接。</span><br><span class="line"></span><br><span class="line">devicename       分配一个名称以连接到资源，或指定</span><br><span class="line">                要断开连接的设备。有两种</span><br><span class="line">                设备名称: 磁盘驱动器(D: 至 Z:)和打印机</span><br><span class="line">                (LPT1: 至 LPT3:)。键入星号而不是</span><br><span class="line">                特定设备名称以分配下一个可用</span><br><span class="line">                设备名称。</span><br><span class="line">\\computername   为控制共享资源的计算机</span><br><span class="line">                的名称。如果计算机名包含空白字符，</span><br><span class="line">                则用引号(&quot; &quot;)将双反斜杠(\\)和计算机名</span><br><span class="line">                括起来。计算机名的长度可以为</span><br><span class="line">                1 至 15 个字符。</span><br><span class="line">\sharename       为共享资源的网络名称。</span><br><span class="line">\volume          指定服务器上的 NetWare 卷。必须已安装并正在运行</span><br><span class="line">                Netware 客户端服务(Windows Workstations)</span><br><span class="line">                或 Netware 网关服务(Windows Server)</span><br><span class="line">                才能连接到 NetWare 服务器。</span><br><span class="line">password         为访问共享资源所需的密码。</span><br><span class="line">*                产生密码提示。在密码提示处</span><br><span class="line">                键入密码时不显示密码。</span><br><span class="line">/USER            指定进行连接的另一个</span><br><span class="line">                用户名。</span><br><span class="line">domainname       指定其他域。如果忽略域，</span><br><span class="line">                则使用当前登录的域。</span><br><span class="line">username         指定登录所使用的用户名。</span><br><span class="line">/SMARTCARD       指定连接将使用智能卡上</span><br><span class="line">                的凭据。</span><br><span class="line">/SAVECRED        指定要保存用户名和密码。</span><br><span class="line">                该开关将被忽略，除非命令提示输入用户名</span><br><span class="line">                和密码。</span><br><span class="line">/HOME            将用户连接到他们的主目录。</span><br><span class="line">/DELETE          取消网络连接并</span><br><span class="line">                从持续连接列表中删除该连接。</span><br><span class="line">/REQUIREINTEGRITY</span><br><span class="line">                需要签名的共享连接。如果提供程序</span><br><span class="line">                不支持签名连接，则操作将失败。</span><br><span class="line">/REQUIREPRIVACY  需要加密的共享连接。如果提供程序</span><br><span class="line">                不支持加密连接，则操作将失败。</span><br><span class="line"></span><br><span class="line">/PERSISTENT      控制持续网络连接的使用。</span><br><span class="line">                默认为上次使用的设置。</span><br><span class="line">YES              进行连接时将它们保存，并在下次</span><br><span class="line">                登录时将它们恢复。</span><br><span class="line">NO               不保存正在进行的连接或随后的</span><br><span class="line">                连接；下次登录时将恢复</span><br><span class="line">                现有连接。使用 /DELETE 开关删除</span><br><span class="line">                持续连接。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>NET HELP 命令 | MORE 显示帮助，一次显示一屏。
</code></pre>
]]></content>
      <categories>
        <category>操作技巧</category>
      </categories>
      <tags>
        <tag>net use</tag>
      </tags>
  </entry>
  <entry>
    <title>VMWare-安装-gentoo-livecd-linux</title>
    <url>/2021/10/28/VMWare-%E5%AE%89%E8%A3%85-gentoo-livecd-linux/</url>
    <content><![CDATA[<p>gentoo 比起 Arch Linux 安装貌似难了些，整个过程需要编译，自然就费时间和系统资源了。尝试了好几遍没有成功，转过头来利用 gentoo livecd 尝试一下，找找感觉。</p>
<span id="more"></span>

<p>同样，对 VMware 这里就不再赘述了。</p>
<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><h3 id="系统镜像-ISO-下载"><a href="#系统镜像-ISO-下载" class="headerlink" title="系统镜像 ISO 下载"></a>系统镜像 ISO 下载</h3><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/20160704/livedvd-amd64-multilib-20160704.iso">https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/20160704/livedvd-amd64-multilib-20160704.iso</a>,就利用这个版本吧。</p>
<h3 id="切换安装模式"><a href="#切换安装模式" class="headerlink" title="切换安装模式"></a>切换安装模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure>

<h3 id="分区和创建文件系统"><a href="#分区和创建文件系统" class="headerlink" title="分区和创建文件系统"></a>分区和创建文件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sgdisk --zap-all /dev/sda</span><br><span class="line">cfdisk -z /dev/sda</span><br></pre></td></tr></table></figure>
<p>分成三个区（&#x2F;，&#x2F;boot ，swap），格式化分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.vfat -F32 /dev/sda1</span><br><span class="line">mkswap /dev/sda2 -L Swap</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure>
<p>创建文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/gentoo</span><br><span class="line">mount /dev/sda3 /mnt/gentoo</span><br><span class="line">mkdir -p /mnt/gentoo/boot</span><br><span class="line">mount /dev/sda1 /mnt/gentoo/boot</span><br></pre></td></tr></table></figure>
<h3 id="目标-gentoo-Linux-配置"><a href="#目标-gentoo-Linux-配置" class="headerlink" title="目标 gentoo Linux 配置"></a>目标 gentoo Linux 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /mnt/gentoo</span><br></pre></td></tr></table></figure>
<p>将 livecd 目录下的文件全部靠背到 <code>/mnt/gentoo</code> 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -av /mnt/livecd/* /mnt/gentoo </span><br></pre></td></tr></table></figure>

<h3 id="准备-chroot"><a href="#准备-chroot" class="headerlink" title="准备 chroot"></a>准备 chroot</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp --dereference /etc/resolv.conf /mnt/gentoo/etc/</span><br><span class="line">mount -t proc /proc /mnt/gentoo/proc</span><br><span class="line">mount --rbind /sys /mnt/gentoo/sys</span><br><span class="line">mount --make-rslave /mnt/gentoo/sys</span><br><span class="line">mount --rbind /dev /mnt/gentoo/dev</span><br><span class="line">mount --make-rslave /mnt/gentoo/dev</span><br></pre></td></tr></table></figure>
<h3 id="配置root-密码"><a href="#配置root-密码" class="headerlink" title="配置root 密码"></a>配置<code>root</code> 密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h3 id="拷贝必要的用户文件"><a href="#拷贝必要的用户文件" class="headerlink" title="拷贝必要的用户文件"></a>拷贝必要的用户文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /etc/passwd /mnt/gentoo/etc/passwd</span><br><span class="line">cp /etc/shadow /mnt/gentoo/etc/shadow</span><br></pre></td></tr></table></figure>
<h3 id="配置更新源"><a href="#配置更新源" class="headerlink" title="配置更新源"></a>配置更新源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /mnt/gentoo/etc/portage/make.conf</span><br></pre></td></tr></table></figure>
<p>加入：<code>GENTOO_MIRRORS=&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo/&quot;</code></p>
<h3 id="配置新环境"><a href="#配置新环境" class="headerlink" title="配置新环境"></a>配置新环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot /mnt/gentoo /bin/bash</span><br><span class="line">source /etc/profile</span><br><span class="line">export  PS1=&quot;(chroot) $&#123;PS1&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genkernel [----menuconfig] all</span><br></pre></td></tr></table></figure>
<p>时间很长，耐心等待就好。</p>
<p>首先是创建一个目录。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/gentoo/etc/portage/repos.conf </span><br></pre></td></tr></table></figure>
<p>创建 gentoo.conf 文件并编辑一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gentoo]</span><br><span class="line">location = /usr/portage</span><br><span class="line">sync-type = rsync</span><br><span class="line">sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage/</span><br><span class="line">auto-sync = yes</span><br><span class="line">###sync-rsync-verify-metamanifest = no ## 我的网络问题，导致无法同步到密钥，如果各位朋友的网络好不要加这一行。</span><br></pre></td></tr></table></figure>
<p>配置 <code>make.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /mnt/gentoo/etc/portage/make.conf</span><br></pre></td></tr></table></figure>
<p>添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMON_FLAGS=&quot;-march=native -O2 -pipe&quot;</span><br><span class="line">GENTOO_MIRRORS=&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br></pre></td></tr></table></figure>
<p>并保存。</p>
<h3 id="配置fstab"><a href="#配置fstab" class="headerlink" title="配置fstab"></a>配置fstab</h3><p>修改&#x2F;etc&#x2F;fstab，输入 <code>#nano /etc/fstab</code> 添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/sda1    /boot   vfat    defaults    0 2</span><br><span class="line">/dev/sda2    /       ext3    defaults    0 1 </span><br><span class="line">/dev/sda3    none    swap    sw          0 0</span><br></pre></td></tr></table></figure>

<h3 id="安装-grub"><a href="#安装-grub" class="headerlink" title="安装 grub"></a>安装 grub</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av --oneshot grub</span><br></pre></td></tr></table></figure>

<h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge-webrsync</span><br><span class="line">emerge --sync</span><br></pre></td></tr></table></figure>

<h3 id="选择-profile"><a href="#选择-profile" class="headerlink" title="选择 profile"></a>选择 profile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect profile list</span><br><span class="line">eselect profile set X</span><br></pre></td></tr></table></figure>

<p>安装 <code>cpuid2cpuflags</code> 软件，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av --oneshot app-portage/cpuid2cpuflags</span><br></pre></td></tr></table></figure>
<p>重新安装一遍 gcc ，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av --oneshot gcc</span><br></pre></td></tr></table></figure>
<p>切换到新版本GCC：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect gcc list</span><br><span class="line">eselect gcc set X</span><br></pre></td></tr></table></figure>
<p>安装 ccache </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av dev-util/ccache</span><br></pre></td></tr></table></figure>

<p>完成安装后，用以下命令创建目录，设置权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/cache/ccache</span><br><span class="line">chown root:portage /var/cache/ccache</span><br><span class="line">chmod 2775 /var/cache/ccache</span><br></pre></td></tr></table></figure>
<p>编辑 <code>ccache</code> 配置文件 <code>/var/cache/ccache/ccache.conf</code> ，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max_size = 100.0G</span><br><span class="line">umask = 002</span><br><span class="line">cache_dir_levels = 3</span><br></pre></td></tr></table></figure>
<p>最后到 <code>make.conf</code> 中启用 <code>ccache</code> 就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEATURES=&quot;ccache&quot;</span><br><span class="line">CCACHE_DIR=&quot;/var/cache/ccache&quot;</span><br></pre></td></tr></table></figure>
<h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>

<p>先别纠结这一堆东西有什么意义，一般来说这里会提示类似 &#x2F;etc 下有些文件需要更新，或者出现循环依赖。这些都好办。出现 &#x2F;etc 下需要更新的，直接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc-update --automode -3</span><br></pre></td></tr></table></figure>

<p>出现循环依赖的，就目前几次我安装的经验来看都会提示 pyhon3.9 这个版本需要用 -bluetooth 这个 USE 编译一遍，那么首先我们去 mask 那里新建一个 python 文件，限定好只安装 python3.9 而不是 python3.10 这类的，写法类似上面介绍 mask 的部分，限定好版本然后用下面的命令重装 python3.9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE=-bluetooth emerge -av python</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是 <strong>USE</strong> 的使用，根据提示，和 <em>emerge</em> 配合使用。</p>
<p>完成好这一切工作之后再跑刚才那个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>
<p>这个时候应该就开始运行了。整个编译所需要的时间由你 CPU 性能决定，线程越多，内存越大，速度越快。</p>
<p>如果中途因为某个包挂了，可以尝试以下两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge @preserved-rebuild</span><br><span class="line">perl-cleaner --all</span><br></pre></td></tr></table></figure>
<p>重复运行更新命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>

<h3 id="配置基础系统"><a href="#配置基础系统" class="headerlink" title="配置基础系统"></a>配置基础系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br><span class="line">emerge --config sys-libs/timezone-data</span><br><span class="line"></span><br><span class="line">echo &quot;en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen</span><br><span class="line"></span><br><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<p>查看我们目前可选择的语言和设定该语言为我们系统语言，建议各位先不要定义语言为中文，因为目前的 TTY 下是不支持中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect locale list</span><br><span class="line">eselect locale set X</span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对树内文件系统的系统管理员</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av sys-fs/btrfs-progs sys-fs/xfsprogs sys-fs/jfsutils networkmanager app-admin/sysklogd sys-process/cronie layman sudo grub dev-vcs/git</span><br></pre></td></tr></table></figure>
<p>因为我使用 <code>systemd</code> ，所以我在这里就默认 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure>
<p>如果你是 sudo 用户，使用以下代码给 wheel 用户组能够使用 sudo 的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\# \%wheel ALL=(ALL) ALL/\%wheel ALL=(ALL) ALL/g&#x27; /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>我们现在可以配置我们的 root 用户密码了，直接 <code>passwd</code> 就可以了，默认情况下 Gentoo 要求非常严格的密码，我也不清楚怎么修改这个严格程度，所以大家知道的可以留言告诉我。</p>
<p>非常感谢 crackself 朋友的留言给我提供了思路。具体设置 Gentoo Linux passwd 密码强度是这样的。首先我们可以查看两个配置文件， <code>/etc/pam.d/passwd</code> 和 <code>/etc/pam.d/system-auth</code> 大家会注意到后者告诉我们相关配置文件在 <code>/etc/security/passwdqc.conf</code> 。所以，我们只需要设置这个配置文件就好了，那么默认的情况大概是这样的（之所以说是大概是因为我忘记默认配置文件了）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min=disabled,24,11,8,7</span><br><span class="line">max=40</span><br><span class="line">passphrase=8</span><br><span class="line">match=4</span><br><span class="line">similar=deny</span><br><span class="line">random=47</span><br><span class="line">enforce=everyone</span><br><span class="line">retry=3</span><br></pre></td></tr></table></figure>
<p>我后面修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min=3,3,3,3,3</span><br><span class="line">max=8</span><br><span class="line">passphrase=0</span><br><span class="line">match=4</span><br><span class="line">similar=permit</span><br><span class="line">random=47</span><br><span class="line">enforce=everyone</span><br><span class="line">retry=3</span><br></pre></td></tr></table></figure>
<p>这样就能设置简单的 <code>passwd</code> 密码了。具体这些值意味这什么，大家可以参考这篇文章获得启发。这里发散一下思维，假设你现在看到这篇文章的时候，已经完成了整个系统的安装，而且和我一样使用了 Gnome 桌面环境，那么通过上面的方法虽然你已经完成了登陆密码和 passwd 的密码修改，但是 gnome 的密码密钥却还是以前老的，如果你打开 chrome 或者 vivaldi 的时候，会要求你输入密码解锁。那么如何解决呢？需要你安装 <code>app-crypt/seahorse</code> 包，安装好之后，将默认的密码修改成你登录系统的密码，这样将来就不会要求重新输入密码了。</p>
<p>完善一下 <code>grub</code> 的配置，我并没有像 Yangmame 巨菊那样设置。只是在 <code>/etc/default/grub</code> 底部增加了一行，最后关于 grub 和 systemd-boot 的设置，我们第一部分结束前再弄，现在不急：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_DISABLE_OS_PROBER=false</span><br></pre></td></tr></table></figure>
<p>再输入下面两行代码，以防万一，虽然不输入，好像也没有关系，因为有一次安装我忘记了，也能正常用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -sf /proc/self/mounts /etc/mtab</span><br><span class="line">systemd-machine-id-setup</span><br></pre></td></tr></table></figure>
<h3 id="编译内核-1"><a href="#编译内核-1" class="headerlink" title="编译内核"></a>编译内核</h3>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Arch Linux</tag>
        <tag>gentoo</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware 安装 gentoo Linux</title>
    <url>/2021/10/26/VMware-%E5%AE%89%E8%A3%85-gentoo-Linux/</url>
    <content><![CDATA[<p>gentoo 比起 Arch Linux 安装貌似难了些，整个过程需要编译，自然就费时间和系统资源了。来吧，为了写出通俗易懂的文字，亲自实测记录。</p>
<span id="more"></span>

<p>同样，对 VMware 这里就不再赘述了。</p>
<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><h3 id="系统镜像-ISO-下载"><a href="#系统镜像-ISO-下载" class="headerlink" title="系统镜像 ISO 下载"></a>系统镜像 ISO 下载</h3><p>下载地址：<a href="https://github.com/HougeLangley/archzfs-iso/releases">https://github.com/HougeLangley/archzfs-iso/releases</a>,<br>我喜欢最新版本。</p>
<h3 id="分区和创建文件系统"><a href="#分区和创建文件系统" class="headerlink" title="分区和创建文件系统"></a>分区和创建文件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sgdisk --zap-all /dev/sda</span><br><span class="line">cfdisk -z /dev/sda</span><br></pre></td></tr></table></figure>
<p>分成三个区（&#x2F;，&#x2F;boot ，swap），格式化分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.vfat -F32 /dev/sda1</span><br><span class="line">mkswap /dev/sda2 -L Swap</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure>
<p>创建文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/gentoo</span><br><span class="line">mount /dev/sda3 /mnt/gentoo</span><br><span class="line">mkdir -p /mnt/gentoo/boot</span><br><span class="line">mount /dev/sda1 /mnt/gentoo/boot</span><br></pre></td></tr></table></figure>
<h3 id="目标-gentoo-Linux-配置"><a href="#目标-gentoo-Linux-配置" class="headerlink" title="目标 gentoo Linux 配置"></a>目标 gentoo Linux 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /mnt/gentoo</span><br></pre></td></tr></table></figure>
<p>准备 stage3 ，用的清华镜像的 systemd。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsighua.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64-systemd/stage3-amd64-systemd-20211018T200943Z.tar.xz</span><br></pre></td></tr></table></figure>
<p>然后解压，并删除此文件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvpf stage3-amd64-systemd-20211018T200943Z.tar.xz</span><br><span class="line">rm stage3-amd64-systemd-20211018T200943Z.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="配置-ssh-访问"><a href="#配置-ssh-访问" class="headerlink" title="配置 ssh 访问"></a>配置 ssh 访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service</span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line">ssh ipaddress -l root</span><br></pre></td></tr></table></figure>

<h3 id="生成-fstab-文件"><a href="#生成-fstab-文件" class="headerlink" title="生成 fstab 文件"></a>生成 fstab 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt/gentoo &gt;&gt; /mnt/gentoo/etc/fstab </span><br><span class="line">cat /mnt/gentoo/etc/fstab</span><br></pre></td></tr></table></figure>
<h3 id="定制-Gentoo-Linux"><a href="#定制-Gentoo-Linux" class="headerlink" title="定制 Gentoo Linux"></a>定制 Gentoo Linux</h3><p>需要配置 <strong>&#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;make.conf</strong> ，**&#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;** ， <strong>&#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;repos.conf&#x2F;gentoo.conf</strong> 这些文件。</p>
<ol>
<li>配置 <code>make.conf</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /mnt/gentoo/etc/portage/make.conf</span><br></pre></td></tr></table></figure>
配置文件如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">#注释信息</span><br><span class="line">#</span><br><span class="line">#COMMON_FLAGS=&quot;-march=skylake -O3 -pipe&quot;</span><br><span class="line">COMMON_FLAGS=&quot;-march=skylake --Ofast -pipe&quot;</span><br><span class="line">CFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">CXXFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">FCFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">FFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">#CPU_FLAGS_X86=&quot;aes avx f16c mmx mmxext pclmul popcnt rdrand sse sse2 sse3 sse4_1 sse4_2 ssse3&quot;</span><br><span class="line"></span><br><span class="line">#PORTDIR=&quot;/var/db/repos/gentoo&quot;</span><br><span class="line">#DISTDIR=&quot;/var/cache/distfiles&quot;</span><br><span class="line">#PKGDIR=&quot;/var/cache/binpkgs&quot;</span><br><span class="line"></span><br><span class="line">LC_MESSAGES=C</span><br><span class="line">MAKEOPTS=&quot;-j40&quot;</span><br><span class="line">GENTOO_MIRRORS=&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br><span class="line">EMERGE_DEFAULT_OPTS=&quot;--keep-going --with-bdeps=y&quot;</span><br><span class="line"></span><br><span class="line">#ACCEPT_KEYWORDS=&quot;~amd64&quot;</span><br><span class="line">ACCEPT_LICENSE=&quot;*&quot;</span><br><span class="line">L10N=&quot;en-US zh-CN en zh&quot;</span><br><span class="line">LINGUAS=&quot;en_US zh_CN en zh&quot;</span><br><span class="line">GRUB_PLATFORMS=&quot;efi-64&quot;</span><br><span class="line">VIDEO_CARDS=&quot;nvidia&quot;</span><br><span class="line">RUBY_TARGETS=&quot;ruby30&quot;</span><br><span class="line">#QEMU_SOFTMMU_TARGETS=&quot;alpha aarch64 arm i386 mips mips64 mips64el mipsel ppc ppc64 s390x sh4 sh4eb sparc sparc64 x86_64&quot;</span><br><span class="line">#QEMU_USER_TARGETS=&quot;alpha aarch64 arm armeb i386 mips mipsel ppc ppc64 ppc64abi32 s390x sh4 sh4eb sparc sparc32plus sparc64 x86_64&quot;</span><br><span class="line">LLVM_TARGETS=&quot;X86&quot;</span><br><span class="line">FEATURES=&quot;ccache&quot;</span><br><span class="line">CCACHE_DIR=&quot;/var/cache/ccache&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义一些 USE<br>定义 python 版本，为后续编译工作打下基础。新建 <code>vim /mnt/gentoo/etc/portage/package.use/python</code> 可以像这样：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/* PYTHON_TARGETS: -python2_7</span><br><span class="line">*/* PYTHON_COMPAT: python3_9 python3_10</span><br></pre></td></tr></table></figure></li>
</ol>
<p>打开 GCC lto 和 pgo 优化，新建 <code>vim /mnt/gentoo/etc/portage/package.use/gcc</code> ，输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys-devel/gcc pgo lto</span><br></pre></td></tr></table></figure>

<p>新建 <code>vim /mnt/gentoo/etc/portage/package.use/ghostscript-gpl</code> ，输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app-text/ghostscript-gpl -l10n_zh-CN</span><br></pre></td></tr></table></figure>
<p>这样就不会桌面系统安装楷体了。</p>
<p>选择 <code>systemd-boot</code> ，同样在上面那个目录创建一个文件 <code>vim /mnt/gentoo/etc/portage/package.use/systemd</code>，输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys-apps/systemd gnuefi</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置官方源</li>
</ol>
<p>首先是创建一个目录。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/gentoo/etc/portage/repos.conf </span><br></pre></td></tr></table></figure>
<p>这个目录的意义是所有的源地址配置文件都会放到这里，于是在这个目录下创建 gentoo.conf 官方源文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gentoo]</span><br><span class="line">location = /usr/portage</span><br><span class="line">sync-type = rsync</span><br><span class="line">sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage/</span><br><span class="line">auto-sync = yes</span><br><span class="line">sync-rsync-verify-metamanifest = no ## 我的网络问题，导致无法同步到密钥，如果各位朋友的网络好不要加这一行。</span><br></pre></td></tr></table></figure>
<h3 id="准备-chroot"><a href="#准备-chroot" class="headerlink" title="准备 chroot"></a>准备 chroot</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp --dereference /etc/resolv.conf /mnt/gentoo/etc/</span><br><span class="line">mount -t proc /proc /mnt/gentoo/proc</span><br><span class="line">mount --rbind /sys /mnt/gentoo/sys</span><br><span class="line">mount --make-rslave /mnt/gentoo/sys</span><br><span class="line">mount --rbind /dev /mnt/gentoo/dev</span><br><span class="line">mount --make-rslave /mnt/gentoo/dev</span><br><span class="line">chroot /mnt/gentoo /bin/bash</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge-webrsync</span><br><span class="line">emerge --sync</span><br></pre></td></tr></table></figure>

<h3 id="选择-profile"><a href="#选择-profile" class="headerlink" title="选择 profile"></a>选择 profile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect profile list</span><br><span class="line">eselect profile set X</span><br></pre></td></tr></table></figure>

<p>安装 <code>cpuid2cpuflags</code> 软件，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av --oneshot app-portage/cpuid2cpuflags</span><br></pre></td></tr></table></figure>
<p>重新安装一遍 gcc ，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av --oneshot gcc</span><br></pre></td></tr></table></figure>
<p>切换到新版本GCC：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect gcc list</span><br><span class="line">eselect gcc set X</span><br></pre></td></tr></table></figure>
<p>安装 ccache </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av dev-util/ccache</span><br></pre></td></tr></table></figure>

<p>完成安装后，用以下命令创建目录，设置权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/cache/ccache</span><br><span class="line">chown root:portage /var/cache/ccache</span><br><span class="line">chmod 2775 /var/cache/ccache</span><br></pre></td></tr></table></figure>
<p>编辑 <code>ccache</code> 配置文件 <code>/var/cache/ccache/ccache.conf</code> ，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max_size = 100.0G</span><br><span class="line">umask = 002</span><br><span class="line">cache_dir_levels = 3</span><br></pre></td></tr></table></figure>
<p>最后到 <code>make.conf</code> 中启用 <code>ccache</code> 就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEATURES=&quot;ccache&quot;</span><br><span class="line">CCACHE_DIR=&quot;/var/cache/ccache&quot;</span><br></pre></td></tr></table></figure>
<h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>

<p>先别纠结这一堆东西有什么意义，一般来说这里会提示类似 &#x2F;etc 下有些文件需要更新，或者出现循环依赖。这些都好办。出现 &#x2F;etc 下需要更新的，直接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc-update --automode -3</span><br></pre></td></tr></table></figure>

<p>出现循环依赖的，就目前几次我安装的经验来看都会提示 pyhon3.9 这个版本需要用 -bluetooth 这个 USE 编译一遍，那么首先我们去 mask 那里新建一个 python 文件，限定好只安装 python3.9 而不是 python3.10 这类的，写法类似上面介绍 mask 的部分，限定好版本然后用下面的命令重装 python3.9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE=-bluetooth emerge -av python</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是 <strong>USE</strong> 的使用，根据提示，和 <em>emerge</em> 配合使用。</p>
<p>完成好这一切工作之后再跑刚才那个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>
<p>这个时候应该就开始运行了。整个编译所需要的时间由你 CPU 性能决定，线程越多，内存越大，速度越快。</p>
<p>如果中途因为某个包挂了，可以尝试以下两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge @preserved-rebuild</span><br><span class="line">perl-cleaner --all</span><br></pre></td></tr></table></figure>
<p>重复运行更新命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -auvDN --with-bdeps=y --autounmask-write @world</span><br></pre></td></tr></table></figure>

<h3 id="配置基础系统"><a href="#配置基础系统" class="headerlink" title="配置基础系统"></a>配置基础系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br><span class="line">emerge --config sys-libs/timezone-data</span><br><span class="line"></span><br><span class="line">echo &quot;en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen</span><br><span class="line"></span><br><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<p>查看我们目前可选择的语言和设定该语言为我们系统语言，建议各位先不要定义语言为中文，因为目前的 TTY 下是不支持中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eselect locale list</span><br><span class="line">eselect locale set X</span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对树内文件系统的系统管理员</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emerge -av sys-fs/btrfs-progs sys-fs/xfsprogs sys-fs/jfsutils networkmanager app-admin/sysklogd sys-process/cronie layman sudo grub dev-vcs/git</span><br></pre></td></tr></table></figure>
<p>因为我使用 <code>systemd</code> ，所以我在这里就默认 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure>
<p>如果你是 sudo 用户，使用以下代码给 wheel 用户组能够使用 sudo 的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\# \%wheel ALL=(ALL) ALL/\%wheel ALL=(ALL) ALL/g&#x27; /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>我们现在可以配置我们的 root 用户密码了，直接 <code>passwd</code> 就可以了，默认情况下 Gentoo 要求非常严格的密码，我也不清楚怎么修改这个严格程度，所以大家知道的可以留言告诉我。</p>
<p>非常感谢 crackself 朋友的留言给我提供了思路。具体设置 Gentoo Linux passwd 密码强度是这样的。首先我们可以查看两个配置文件， <code>/etc/pam.d/passwd</code> 和 <code>/etc/pam.d/system-auth</code> 大家会注意到后者告诉我们相关配置文件在 <code>/etc/security/passwdqc.conf</code> 。所以，我们只需要设置这个配置文件就好了，那么默认的情况大概是这样的（之所以说是大概是因为我忘记默认配置文件了）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min=disabled,24,11,8,7</span><br><span class="line">max=40</span><br><span class="line">passphrase=8</span><br><span class="line">match=4</span><br><span class="line">similar=deny</span><br><span class="line">random=47</span><br><span class="line">enforce=everyone</span><br><span class="line">retry=3</span><br></pre></td></tr></table></figure>
<p>我后面修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min=3,3,3,3,3</span><br><span class="line">max=8</span><br><span class="line">passphrase=0</span><br><span class="line">match=4</span><br><span class="line">similar=permit</span><br><span class="line">random=47</span><br><span class="line">enforce=everyone</span><br><span class="line">retry=3</span><br></pre></td></tr></table></figure>
<p>这样就能设置简单的 <code>passwd</code> 密码了。具体这些值意味这什么，大家可以参考这篇文章获得启发。这里发散一下思维，假设你现在看到这篇文章的时候，已经完成了整个系统的安装，而且和我一样使用了 Gnome 桌面环境，那么通过上面的方法虽然你已经完成了登陆密码和 passwd 的密码修改，但是 gnome 的密码密钥却还是以前老的，如果你打开 chrome 或者 vivaldi 的时候，会要求你输入密码解锁。那么如何解决呢？需要你安装 <code>app-crypt/seahorse</code> 包，安装好之后，将默认的密码修改成你登录系统的密码，这样将来就不会要求重新输入密码了。</p>
<p>完善一下 <code>grub</code> 的配置，我并没有像 Yangmame 巨菊那样设置。只是在 <code>/etc/default/grub</code> 底部增加了一行，最后关于 grub 和 systemd-boot 的设置，我们第一部分结束前再弄，现在不急：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_DISABLE_OS_PROBER=false</span><br></pre></td></tr></table></figure>
<p>再输入下面两行代码，以防万一，虽然不输入，好像也没有关系，因为有一次安装我忘记了，也能正常用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -sf /proc/self/mounts /etc/mtab</span><br><span class="line">systemd-machine-id-setup</span><br></pre></td></tr></table></figure>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Arch Linux</tag>
        <tag>gentoo</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware 安装 Arch Linux</title>
    <url>/2021/10/25/VMware-%E5%AE%89%E8%A3%85-Arch-Linux/</url>
    <content><![CDATA[<p>这里只记录在虚拟机中安装过程，至于 VMware 就不在赘述了。需要说明一点的是需要配置虚拟机高级选项的“固件类型”为 “UEFI”。</p>
<span id="more"></span>

<h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>下载 Arch Linux ISO 添加到 VMware 启动项，启动安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@archiso ~ #</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ls /sys/firmware/efi/efivars</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加网络"><a href="#添加网络" class="headerlink" title="添加网络"></a>添加网络</h3><p>VMware 初始开启网络链接状态 （NAT)</p>
<h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">timedatectl set-ntp true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="建立硬盘分区"><a href="#建立硬盘分区" class="headerlink" title="建立硬盘分区"></a>建立硬盘分区</h3><p>所选为 GPT&#x2F;UEFI 模式，故只分 EFI , swap 和 &#x2F; 对应分区为 &#x2F;dev&#x2F;sda1 , &#x2F;dev&#x2F;sda2 ,&#x2F;dev&#x2F;sda3 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>格式化分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line">mkswap /dev/sda2 -L Swap</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="挂在分区"><a href="#挂在分区" class="headerlink" title="挂在分区"></a>挂在分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><h3 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h3><p>打开文件并将 <code>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</code> 添加到地址列的第一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>

<h3 id="基本系统安装"><a href="#基本系统安装" class="headerlink" title="基本系统安装"></a>基本系统安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacstrap  -i /mnt base base-devel linux linux-firmware vim dhcpcd openssh net-tools xfsprogs man</span><br></pre></td></tr></table></figure>
<p>一路默认回车就好。</p>
<h3 id="生成-fstab-文件"><a href="#生成-fstab-文件" class="headerlink" title="生成 fstab 文件"></a>生成 fstab 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab </span><br></pre></td></tr></table></figure>

<h2 id="切换到新系统"><a href="#切换到新系统" class="headerlink" title="切换到新系统"></a>切换到新系统</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置时区"><a href="#配置时区" class="headerlink" title="配置时区"></a>配置时区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>

<h3 id="配置本地-locale"><a href="#配置本地-locale" class="headerlink" title="配置本地 locale"></a>配置本地 locale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
<p>将 <code>en_US.UTF-8</code> 和 <code>zh_CN&gt;UTF-8</code> 前 ”#“ 删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br><span class="line">echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable dhcpcd.service</span><br></pre></td></tr></table></figure>

<h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><p>root 用户密码配置，添加新用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd</span><br><span class="line">useradd -m -G wheel -s /bin/bash username</span><br><span class="line">passwd username</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure>

<p>修改 &#x2F;etc&#x2F;sudoers, 将 ”# %wheel ALL&#x3D;(ALL) ALL” 中的 “#” 删除</p>
<h3 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h3><p>因为采用 GPT&#x2F;UEFI 模式，故只安装 grub 和 efibootmgr。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure>
<p>安装 EFI 中,<code>sda</code> 后不要加编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub-install --recheck /dev/sda</span><br></pre></td></tr></table></figure>
<p>生成 grub 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Arch Linux 的安装还算简单，不过安装桌面我觉得就没的必要了，接下来要研究 <code>gentoo</code> ，感觉比较烧脑，桌面就在这里在研究吧。<br>gentoo 真心不好弄，慢慢来，不管花多少时间一定要啃下来。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>Arch Linux</tag>
        <tag>command line</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/06/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>range()函数</title>
    <url>/2021/06/27/range%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(1,10,11):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>以上代码的输出是什么呢？</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>range()</tag>
      </tags>
  </entry>
  <entry>
    <title>tired!</title>
    <url>/2022/10/13/tired/</url>
    <content><![CDATA[<h3 id="Tired"><a href="#Tired" class="headerlink" title="Tired!"></a>Tired!</h3>]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>tired</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2023/06/01/testing/</url>
    <content><![CDATA[<p>现在网上太多的毒鸡汤，他告诉你说你想要的，岁月都会给你，但是他没有告诉你想要的岁月，凭什么给你？都说站在风口上，猪都能飞起来。但前提是你得闲站上去，不然，你等风来只吹你？这现实吗？你招风吗？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>毒鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>冒个泡.md</title>
    <url>/2022/10/09/%E5%86%92%E4%B8%AA%E6%B3%A1-md/</url>
    <content><![CDATA[<h2 id="好久没发博客了，随便写几笔吧，代表我还能写。"><a href="#好久没发博客了，随便写几笔吧，代表我还能写。" class="headerlink" title="好久没发博客了，随便写几笔吧，代表我还能写。"></a>好久没发博客了，随便写几笔吧，代表我还能写。</h2>]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>冒水</tag>
        <tag>冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title>函数定义.Python</title>
    <url>/2022/04/19/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-Python/</url>
    <content><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><span id="more"></span>
<pre><code>def function_name(self,[parameters...]):
    statements
    ...
</code></pre>
<h2 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h2><pre><code>function_name(...)
</code></pre>
<h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><pre><code>import module
def f_name(self,[parameters...]):
    statements
    ...

if __name__==&#39;__main__&#39;:
    f_name(self,...)
</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>函数（function）</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>下载利器IDM</title>
    <url>/2020/12/18/%E4%B8%8B%E8%BD%BD%E5%88%A9%E5%99%A8IDM/</url>
    <content><![CDATA[<p>分享一个下载利器 <a href="https://pan.baidu.com/s/1oz2Nqg8LR-NzvA9c8sx7Rw"><strong>IDM</strong></a> 提取码：cl6f。</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>IDM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Win10+Node.js+Git+Hexo在GitHub快速部署博客（恢复）</title>
    <url>/2018/12/01/%E5%88%A9%E7%94%A8Win10-Node-js-Git-Hexo%E5%9C%A8GitHub%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2-2018-12-01/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客，仅音译，英文名为Blogger,为Web Log的混成词。它的正式名称为网络日记；又音译为部落格或部落阁等。博客是继MSN.BBS.ICQ之后出现的第4种网络交流方式，现已受到大家的欢迎，是网络时代的个人“读者文摘”，是以超级链接为武器的网络日记，它代表着新的生活、工作和学习方式。许多博客专注在特定的课题上提供评论或新闻，其他则被作为比较个人的日记。一个典型的博客结合了文字、图像、其他博客或网站的链接及其它与主题相关的媒体，能够让读者以互动的方式留下意见，是许多博客的重要要素。大部分的博客内容以文字为主，仍有一些博客专注在IT、艺术、摄影、视频、音乐、播客等各种主题。博客是社会媒体网络的一部分。比较著名的有Facebook、新浪、网易等。当下网络如此发达，你不想用有一个自己的博客吗？如果你想要具有一个自己的博客，并且自行定制自己的博客，需要怎么做呢？今天我就以他人受之渔受有缘人。</p>
<span id="more"></span>

<h2 id="Windows10下环境搭建"><a href="#Windows10下环境搭建" class="headerlink" title="Windows10下环境搭建"></a>Windows10下环境搭建</h2><p>以下利用之软件大多皆是开源软件，在Windows下有些软件难免要有版权，如果介意请尽快切换到Linux系统。不过用习惯Windows了要想转Linux还需要一个过渡的过程，加油吧。下面将从以下几方面着重叙述构建博客需要的几个过程，软件的下载尽可能去官网。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>可以点击<a href="https://nodejs.org/en/download/">Nodejs官网</a>进行下载，不多赘述，下载64位的（.msi）。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>需要点击<a href="https://visualstudio.microsoft.com/zh-hans/downloads/?rr=https://social.msdn.microsoft.com/Forums/vstudio/en-US/e653a57a-bc32-4134-87bf-df33058f0531/download-microsoft-visual-c-2017-redistributable?forum=vssetup">Microsoft Visual C++2017 x64位</a>下载</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装后，win+R启动cmd命令行，输入</p>
<p><code>$ node -v</code><br><code>v10.13.0</code></p>
<p><code>$ npm -v</code><br><code>6.4.1</code></p>
<p>检测是否安装的最新版本。</p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装完node.js后就可以利用<code>npm</code>包管理程序安装 <code>hexo</code>了，利用以下的命令即可：</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p><code>$npm install hexo -save</code></p>
<h3 id="安装hexo命令行组件"><a href="#安装hexo命令行组件" class="headerlink" title="安装hexo命令行组件"></a>安装hexo命令行组件</h3><p><code>$npm install -g hexo-cli</code></p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p><code>$hexo init [文件夹名]</code></p>
<h3 id="hexo项目内node-js安装"><a href="#hexo项目内node-js安装" class="headerlink" title="hexo项目内node.js安装"></a>hexo项目内node.js安装</h3><p><code>$npm install</code></p>
<h3 id="添加Git支持"><a href="#添加Git支持" class="headerlink" title="添加Git支持"></a>添加Git支持</h3><p><code>$npm install hexo-deployer-git --save</code></p>
<h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p><code>$npm install hexo-generator-feed --save</code></p>
<h3 id="查找功能"><a href="#查找功能" class="headerlink" title="查找功能"></a>查找功能</h3><p><code>$npm install hexo-generator-searchdb --save</code></p>
<h3 id="启动项目服务器，在本地测试"><a href="#启动项目服务器，在本地测试" class="headerlink" title="启动项目服务器，在本地测试"></a>启动项目服务器，在本地测试</h3><p><code>$hexo s</code></p>
<p><code>$hexo -v</code></p>
<p><code>hexo: 3.8.0</code><br><code>hexo-cli: 1.1.0</code><br><code>os: Windows_NT 10.0.17134 win32 x64</code><br><code>http_parser: 2.8.0</code><br><code>node: 10.13.0</code><br><code>v8: 6.8.275.32-node.36</code><br><code>uv: 1.23.2</code><br><code>zlib: 1.2.11</code><br><code>ares: 1.14.0</code><br><code>modules: 64</code><br><code>nghttp2: 1.34.0</code><br><code>napi: 3</code><br><code>openssl: 1.1.0i</code><br><code>icu: 62.1</code><br><code>unicode: 11.0</code><br><code>cldr: 33.1</code><br><code>tz: 2018e</code></p>
<h3 id="Git安装及GitHub配置"><a href="#Git安装及GitHub配置" class="headerlink" title="Git安装及GitHub配置"></a>Git安装及GitHub配置</h3><ol>
<li><a href="https://git-scm.com/download/win">下载地址</a> 选择Windows版本下载，安装按照默认点击“下一步”即可。</li>
<li>配置GitHub<br>注册GitHub账号，<a href="https://github.com/">注册网址：</a>。</li>
</ol>
<p>打开<em>git-bash</em>，配置Git全局变量</p>
<p><code>$ git config --global user.name &quot;username&quot;</code></p>
<p><code>$ git config --global user.email &quot;email-for-git&quot;</code></p>
<p>打开 <em>git-bash</em> 在本地生成SSH key <code>$ ssh-keygen -t rsa -C &quot;email-for-Github&quot;</code>；打开 <em>ssh-agent</em> ， <code>$ eval (ssh-agent -s)</code>；生成私钥 <code>$ ssh-add ~/.ssh/id_rsa</code>；在 <em>.ssh</em> 目录中创建配置文件 <em>config</em>，编辑如下：</p>
<p><code>Host one.github.com</code></p>
<p><code>HostName github.com</code></p>
<p><code>PreferredAuthentications publickey</code></p>
<p><code>IdentityFile ~/.ssh/id_rsa_one</code></p>
<p><code>User one</code></p>
<p>进入账号设置（Settings），配置 SSH keys,将生成的<em>id_rsa.pub</em>中的公钥填入其中；<br>新建一个repository，并命名；进入此repository，选择“Settings”，在GitHub Pages 选项中启用发布网站。</p>
<h3 id="Markdownpad2安装"><a href="#Markdownpad2安装" class="headerlink" title="Markdownpad2安装"></a>Markdownpad2安装</h3><p>所需依赖 <a href="https://pan.baidu.com/s/1ivWd6bc2IBJ0j_qBeD74sg">** Awesomium SDK **下载地址</a>提取码：g656<br><a href="http://markdownpad.com/">Markdownpad2下载地址</a><br>安装略。此软件为编辑hexo生成的 <em>.md</em> 网站文件,也可以用VSCode哦。</p>
<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>hexo主配置文件，主目录下 <em>_config.yml</em></p>
<p>theme配置文件，theme目录下 <em>_config.yml</em></p>
<p>请自行查找配置方法，参看<a href="https://hexo.io/zh-cn/docs/">hexo官网文档</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>千里之行始于足下</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>MarkdownPro2</tag>
        <tag>Node.js</tag>
        <tag>GitHub</tag>
        <tag>npm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>启动python交互模式提示&#39;UnicodeDecodeError&#39;错误的解决办法</title>
    <url>/2021/11/11/%E5%90%AF%E5%8A%A8python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%A4%BA-UnicodeDecodeError-%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>今天启动 python 交互模式的时候，突然有一大段代码提示信息，似乎和以前有很大区别，仔细一看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) C:\WINDOWS\system32&gt;python</span><br><span class="line">Python 3.8.12 (default, Oct 12 2021, 03:01:40) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Failed calling sys.__interactivehook__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;C:\Anaconda3\lib\site.py&quot;, line 440, in register_readline</span><br><span class="line">    readline.read_history_file(history)</span><br><span class="line">File &quot;C:\Anaconda3\lib\site-packages\pyreadline\rlmain.py&quot;, line 165, in read_history_file</span><br><span class="line">    self.mode._history.read_history_file(filename)</span><br><span class="line">File &quot;C:\Anaconda3\lib\site-packages\pyreadline\lineeditor\history.py&quot;, line 82, in read_history_file</span><br><span class="line">    for line in open(filename, &#x27;r&#x27;):</span><br><span class="line">UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0x89 in position 26: illegal multibyte sequence</span><br></pre></td></tr></table></figure>
<p><em><strong>UnicodeDecodeError</strong></em>, Unicode 编码错误。</p>
<span id="more"></span>

<p>由上面的提示的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">File &quot;C:\Anaconda3\lib\site-packages\pyreadline\lineeditor\history.py&quot;, line 82, in read_history_file</span><br><span class="line">    for line in open(filename, &#x27;r&#x27;):</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>利用脚本编辑器打开 <strong>C:\Anaconda3\lib\site-packages\pyreadline\lineeditor\history.py</strong> 文件，找到82行所在的代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def read_history_file(self, filename=None): </span><br><span class="line">    &#x27;&#x27;&#x27;Load a readline history file.&#x27;&#x27;&#x27;</span><br><span class="line">    if filename is None:</span><br><span class="line">        filename = self.history_filename</span><br><span class="line">    try:</span><br><span class="line">        for line in open(filename, &#x27;r&#x27;):</span><br><span class="line">            self.add_history(lineobj.ReadLineTextBuffer(ensure_unicode(line.rstrip())))</span><br><span class="line">    except IOError:</span><br><span class="line">        self.history = []</span><br><span class="line">        self.history_cursor = 0    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for line in open(filename,&#x27;r&#x27;):</span><br></pre></td></tr></table></figure>

<p>中 <code>open(filename,&#39;r&#39;)</code> 修改为： <code>open(filename,&#39;r&#39;,encoding=&#39;utf-8&#39;)</code>。</p>
<p>修改后的代码片段为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def read_history_file(self, filename=None): </span><br><span class="line">    &#x27;&#x27;&#x27;Load a readline history file.&#x27;&#x27;&#x27;</span><br><span class="line">    if filename is None:</span><br><span class="line">        filename = self.history_filename</span><br><span class="line">    try:</span><br><span class="line">        for line in open(filename, &#x27;r&#x27;,encoding=&#x27;utf-8&#x27;):</span><br><span class="line">            self.add_history(lineobj.ReadLineTextBuffer(ensure_unicode(line.rstrip())))</span><br><span class="line">    except IOError:</span><br><span class="line">        self.history = []</span><br><span class="line">        self.history_cursor = 0    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就没有然后了，正常显示如初了。遇到这个问题的伙伴们，去试试吧。</p>
]]></content>
      <categories>
        <category>BUG 修理铺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>交互模式</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用sudo命令在Linux中部署超级用户权限（恢复）</title>
    <url>/2018/12/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-sudo-%E5%91%BD%E4%BB%A4%E5%9C%A8-Linux-%E4%B8%AD%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90-2018-12-02/</url>
    <content><![CDATA[<p><strong>sudo</strong> 命令在你想要使用超级权限运行一条临时的命令时非常方便，但是当它不能做到你期望的所有事的时候，你也会遇到一些麻烦。比如说你想在某些日志文件结尾添加一些重要的信息，你可能会尝试这样做：  </p>
<span id="more"></span>

<pre><code>$ echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied
</code></pre>
<p>好吧，看起来你似乎需要一些额外的特权。一般来说，你不能使用你的用户账号向系统日志中写入东西。我们使用 <strong>sudo</strong> 再尝试一次吧。  </p>
<pre><code>$ sudo !!
sudo echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied
</code></pre>
<p>emmm，它还是没有啥反应。我们来试点不同的吧。  </p>
<pre><code>$ sudo &#39;echo &quot;Important note&quot; &gt;&gt; /var/log/somelog&#39;
sudo: echo &quot;Important note&quot; &gt;&gt; /var/log/somelog: command not found
</code></pre>
<p><strong>也可以查看：</strong><a href="https://www.networkworld.com/article/3242170/linux/invaluable-tips-and-tricks-for-troubleshooting-linux.html">在 Linux 下排查故障的宝贵提示和技巧</a></p>
<h3 id="接下来该干什么？"><a href="#接下来该干什么？" class="headerlink" title="接下来该干什么？"></a>接下来该干什么？</h3><p>上面在执行完第一条命令后的回应显示，我们缺少向日志文件写入时必须的特权。第二次，我们使用 root 权限运行了第一次的命令，但是返回了一个 <strong>没有权限</strong> 的错误。第三次，我们把整个命令放在一个引号里面再运行了一遍，返回了一个 <strong>没有发现命令</strong> 的错误。所以，到底错在哪里了呢？</p>
<ul>
<li><p>第一条命令：没有 root 特权，你无法向这个日志中写入东西。</p>
</li>
<li><p>第二条命令：你的超级权限没有被正确重定位。</p>
</li>
<li><p>第三条命令：Sudo 不理解你用引号括起来的整个 “命令”。</p>
</li>
</ul>
<p>在你的用户还未添加到 sudo 用户组的时候，如果尝试使用 sudo，你可能已经看到过像下面的这么一条命令了：  </p>
<pre><code>nemo is not in the sudoers file. This incident will be reported.
</code></pre>
<h3 id="你可以做什么？"><a href="#你可以做什么？" class="headerlink" title="你可以做什么？"></a>你可以做什么？</h3><p>一个相当简单的选择就是使用 sudo 命令成为 root。鉴于你已经有了 sudo 特权，你可以使用下面的命令执行此操作：  </p>
<pre><code>$ sudo su
[sudo] password for nemo:
</code></pre>
<p>注意这个改变的符号表明了你的新身份。然后你就可以以 root 运行之前的命令了：  </p>
<pre><code>echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
</code></pre>
<p>接着你可以输入 <strong>^d</strong> 返回你之前的身份。当然了，一些 sudo 的配置可能会阻止你使用 sudo 命令成为 root。</p>
<p>用 <strong>su</strong> 命令是另一个切换用户为 root 的选择，但是这需要你知道 root 密码许多人被赋予了访问 sudo 的权限，而且无需提供 root 密码，所以这并不是总有用。  </p>
<p>切换到 root 之后，你就可以以 root 的身份运行任何你想执行的命令了。要想通过这种途径有三个问题 1) 每个想要使用 root 特权的人都需要事先知道 root 的密码（这样很不安全） 2) 如果在运行需要 root 权限的特定命令后未能退出特权状态，你的系统可能会受到一些重大错误的波及。最好 <em>只有</em> 当你真的需要 root 特权，以及能控制好每个 sudo 用户可以拥有多少 root 权限的时候再去使用它。在使用完 root 特权之后，最好及时恢复到普通用户的状态。  </p>
<p>另外请注意，整个讨论的前提是你可以正常地访问 sudo，并且你的访问权限没有受限。详细的内容后面会介绍到。  </p>
<p>还有一个选择就是使用一个不同的命令。如果通过编辑文件从而在其后添加内容是一种选择的话，你也许可以使用 “sudo vi &#x2F;var&#x2F;log&#x2F;somelog”，通过编辑一个活跃的日志文件通常不是一个好办法，因为系统可能会频繁的向这个文件中进行写入操作。  </p>
<p>最后一个但是有点复杂的选择是，使用下列可以解决我们之前看到的问题的命令之一，但是它们涉及到了很多复杂的语法。第一个命令允许你在得到 “没有权限” 的拒绝之后可以使用 !! 重复你的命令：  </p>
<pre><code>$ sudo echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied
$ !!:gs/&gt;/|sudo tee -a / &lt;=====
$ tail -1 /var/log/somelog
Important note
</code></pre>
<p>第二种是通过 sudo 命令，把你想要添加的信息传递给 <strong>tee</strong>。注意，**-a** 指定了你要添加文本的目标文件：  </p>
<pre><code>$ echo &quot;Important note&quot; | sudo tee -a /var/log/somelog
$ tail -1 /var/log/somelog
Important note
</code></pre>
<h3 id="sudo-有多可控？"><a href="#sudo-有多可控？" class="headerlink" title="sudo 有多可控？"></a>sudo 有多可控？</h3><p>回答这个问题最快速的回答就是，它取决于管理它的人。大多数 Linux 的默认设置都非常简单。如果一个用户被安排到了一个特别的组中，例如 <strong>wheel</strong> 或者 <strong>admin</strong> 组，那这个用户无需知道 root 的密码就可以拥有运行任何命令的能力。这就是大多数 Linux 系统中的默认设置。一旦在 <strong>&#x2F;etc&#x2F;group</strong> 中添加了一个用户到了特权组中，这个用户就可以以 root 的权力运行任何命令。另一方面，可以配置 sudo，以便一些用户只能够以 root 身份运行单一指令或者一组命令中的任何一个。  </p>
<p>如果把像下面展示的这些行添加到了 <strong>&#x2F;etc&#x2F;sudoers</strong> 文件中，例如 “nemo” 这个用户可以以 root 身份运行 <strong>whoami</strong> 命令。在现实中，这可能不会造成任何影响，作为一个例子，它做的非常好。  </p>
<pre><code># User alias specification
nemo ALL=(root) NOPASSWD: WHOAMI

# Cmnd alias specification
Cmnd_Alias WHOAMI = /usr/bin/whoami
</code></pre>
<p>注意，我们添加了一个命令别名（Cmnd_Alias），它指定了一个可以运行的命令的全路径，以及一个用户别名，允许这个用户无需密码就可以使用 sudo 执行的单个命令。  </p>
<p>当 nemo 运行 <strong>sudo whoami</strong> 命令的时候，他将会看到这个：  </p>
<pre><code>$ sudo whoami
root
</code></pre>
<p>注意这个，一旦 nemo 使用 sudo 执行了这条命令，<strong>whoami</strong> 会显示此时的用户是 <strong>root</strong>。  </p>
<p>至于其他的命令，nemo 将会看到像这样的一些内容：  </p>
<pre><code>$ sudo date
[sudo] password for nemo:
Sorry, user nemo is not allowed to execute &#39;/bin/date&#39; as root on butterfly.
</code></pre>
<h3 id="sudo-的默认设置"><a href="#sudo-的默认设置" class="headerlink" title="sudo 的默认设置"></a>sudo 的默认设置</h3><p>在默认路径中，我们会利用像下面展示的 <strong>&#x2F;etc&#x2F;sudoers</strong> 文件中的几行：  </p>
<pre><code>$ sudo egrep &quot;admin|sudo&quot; /etc/sudoers
# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL        &lt;=====
# Allow members of group sudo to execute any command
%sudo ALL=(ALL:ALL) ALL &lt;=====
</code></pre>
<p>在这几行中，**%admin** 和 <strong>%sudo</strong> 都说明了任何添加到这些组中的人都可以使用 sudo 命令 以 root 的身份运行任何命令。  </p>
<p>下面列出的是 &#x2F;etc&#x2F;group 中的一行，它意味着每一个在该组中列出的成员，都拥有了 sudo 特权，而无需在 &#x2F;etc&#x2F;sudoers 中进行任何修改。  </p>
<pre><code>sudo:x:27:shs,nemo
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sudo 命令意味着你可以根据需要轻松地部署超级用户的访问权限，而且只有在需要的时候才能赋予用户非常有限的特权访问权限。你可能会遇到一些与简单的 “sudo command” 不同的问题，不过在 <strong>sudo</strong> 的回应中应该会显示你遇到了什么问题。  </p>
<p>欢迎加入 <a href="https://www.facebook.com/NetworkWorld/">Facebook</a> 和 <a href="https://www.linkedin.com/company/network-world">LinkedIn</a> 上的 Network World 社区，并在其中重要的主题下进行留言评论。  </p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkdownPro2</tag>
        <tag>LinuxShell</tag>
      </tags>
  </entry>
  <entry>
    <title>就是一篇随笔随笔</title>
    <url>/2020/12/22/%E5%B0%B1%E6%98%AF%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>兴许若干年后，Linux和Windows一样不可替代吧。:)</p>
<p>2020注定是一个不平凡而又平凡的甲子年，Hang In There！！</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-秋</title>
    <url>/2021/11/14/%E9%9A%8F%E7%AC%94-%E7%A7%8B/</url>
    <content><![CDATA[<h2 id="落日余晖-共克时坚"><a href="#落日余晖-共克时坚" class="headerlink" title="落日余晖 共克时坚"></a>落日余晖 共克时坚</h2><p><img src="/img/autumn.jpg" alt="落日"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>图床测试</tag>
        <tag>共克时艰</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo配置参数</title>
    <url>/2023/06/01/Hexo%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><span id="more"></span>

<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p><strong>_config.yml</strong> </p>
<p>网站的 <strong>配置</strong> 信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong></p>
<p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scaffolds</strong></p>
<p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<p><strong>source</strong></p>
<p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong></p>
<p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
</tr>
<tr>
<td>keywords</td>
<td>网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td>author</td>
<td>您的名字</td>
</tr>
<tr>
<td>language</td>
<td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td>timezone</td>
<td>网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America&#x2F;New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia&#x2F;Shanghai。</td>
</tr>
</tbody></table>
<p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p>
<h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>网址, 必须以 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 开头</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>网站根目录</td>
<td>url’s pathname</td>
</tr>
<tr>
<td>permalink</td>
<td>文章的 永久链接 格式</td>
<td>:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</td>
</tr>
<tr>
<td>permalink_defaults</td>
<td>永久链接中各部分的默认值</td>
<td></td>
</tr>
<tr>
<td>pretty_urls</td>
<td>改写 permalink 的值来美化</td>
<td>URL</td>
</tr>
<tr>
<td>pretty_urls.trailing_index</td>
<td>是否在永久链接中保留尾部的 index.html，设置为 false 时去除</td>
<td>true</td>
</tr>
<tr>
<td>pretty_urls.trailing_html</td>
<td>是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</td>
<td>true</td>
</tr>
</tbody></table>
<p>网站存放在子目录</p>
<p>如果您的网站存放在子目录中，例如 <a href="http://example.com/blog%EF%BC%8C%E5%88%99%E8%AF%B7%E5%B0%86%E6%82%A8%E7%9A%84">http://example.com/blog，则请将您的</a> url 设为 <a href="http://example.com/blog">http://example.com/blog</a> 并把 root 设为 &#x2F;blog&#x2F;。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line">#此时页面的永久链接会变为 http://example.com/foo/bar/</span><br></pre></td></tr></table></figure>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>source_dir</td>
<td>资源文件夹，这个文件夹用来存放内容。</td>
<td>source</td>
</tr>
<tr>
<td>public_dir</td>
<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td>public</td>
</tr>
<tr>
<td>tag_dir</td>
<td>标签文件夹</td>
<td>tags</td>
</tr>
<tr>
<td>archive_dir</td>
<td>归档文件夹</td>
<td>archives</td>
</tr>
<tr>
<td>category_dir</td>
<td>分类文件夹</td>
<td>categories</td>
</tr>
<tr>
<td>code_dir</td>
<td>Include code 文件夹，source_dir 下的子目录</td>
<td>downloads&#x2F;code</td>
</tr>
<tr>
<td>i18n_dir</td>
<td>国际化（i18n）文件夹</td>
<td>:lang</td>
</tr>
<tr>
<td>skip_render</td>
<td>跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</td>
<td></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;mypage/**/*&quot;</span><br><span class="line"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts/test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span><br></pre></td></tr></table></figure>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>new_post_name</td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr>
<td>default_layout</td>
<td>预设布局</td>
<td>post</td>
</tr>
<tr>
<td>auto_spacing</td>
<td>在中文和英文之间加入空格</td>
<td>false</td>
</tr>
<tr>
<td>titlecase</td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr>
<td>external_link</td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td>external_link.enable</td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td>external_link.field</td>
<td>对整个网站（site）生效或仅对文章（post）生效</td>
<td>site</td>
</tr>
<tr>
<td>external_link.exclude</td>
<td>需要排除的域名。主域名和子域名如 www 需分别配置</td>
<td>[]</td>
</tr>
<tr>
<td>filename_case</td>
<td>把文件名称转换为 (1) 小写或 (2) 大写</td>
<td>0</td>
</tr>
<tr>
<td>render_drafts</td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr>
<td>post_asset_folder</td>
<td>启动 Asset 文件夹</td>
<td>false</td>
</tr>
<tr>
<td>relative_link</td>
<td>把链接改为与根目录的相对位址</td>
<td>false</td>
</tr>
<tr>
<td>future</td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr>
<td>highlight</td>
<td>代码块的设置, 请参考 Highlight.js 进行设置</td>
<td></td>
</tr>
<tr>
<td>prismjs</td>
<td>代码块的设置, 请参考 PrismJS 进行设置</td>
<td></td>
</tr>
</tbody></table>
<p><strong>相对地址</strong></p>
<p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com，您有一篇文章名为 hello，那么绝对链接可能像这样： <a href="http://example.com/hello.html">http://example.com/hello.html</a> ，它是绝对于域名的。相对链接像这样： &#x2F;hello.html ，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>&amp;</th>
<th>标签</th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>描述</td>
<td>默认值</td>
</tr>
<tr>
<td>default_category</td>
<td>默认分类</td>
<td>uncategorized</td>
</tr>
<tr>
<td>category_map</td>
<td>分类别名</td>
<td></td>
</tr>
<tr>
<td>tag_map</td>
<td>标签别名</td>
<td></td>
</tr>
</tbody></table>
<p><strong>日期 &#x2F; 时间格式</strong></p>
<p>Hexo 使用 Moment.js 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>date_format</td>
<td>日期格式</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td>time_format</td>
<td>时间格式</td>
<td>HH:mm:ss</td>
</tr>
<tr>
<td>updated_option</td>
<td>当 Front Matter 中没有指定 updated 时 updated 的取值</td>
<td>mtime</td>
</tr>
</tbody></table>
<p><strong>updated_option</strong></p>
<p>updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值：</p>
<p>mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</p>
<p>date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</p>
<p>empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。</p>
<p>use_date_for_updated 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 updated_option: ‘date’。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>per_page</td>
<td>每页显示的文章量 (0 &#x3D; 关闭分页功能)</td>
<td>10</td>
</tr>
<tr>
<td>pagination_dir</td>
<td>分页目录</td>
<td>page</td>
</tr>
</tbody></table>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>theme</td>
<td>当前主题名称。值为false时禁用主题</td>
</tr>
<tr>
<td>theme_config</td>
<td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</td>
</tr>
<tr>
<td>deploy</td>
<td>部署部分的设置</td>
</tr>
</tbody></table>
<p><strong>meta_generator</strong>	</p>
<p>Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</p>
<p><strong>包括或不包括目录和文件</strong></p>
<p>在 Hexo 配置文件中，通过设置 include&#x2F;exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 glob 表达式 对目录和文件进行匹配。</p>
<p>include 和 exclude 选项只会应用到 source&#x2F; ，而 ignore 选项会应用到所有文件夹.</p>
<p>|参数	|描述|<br>|include	|Hexo 默认会不包括 source&#x2F; 下的文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。|<br>|exclude	|Hexo 不包括 source&#x2F; 下的这些文件和目录|<br>|ignore	|Hexo 会忽略整个 Hexo 项目下的这些文件夹或文件|</p>
<p>举例：</p>
<p>#处理或不处理目录或文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include:</span><br><span class="line">  - &quot;.nojekyll&quot;</span><br><span class="line">  # 处理 &#x27;source/css/_typing.css&#x27;</span><br><span class="line">  - &quot;css/_typing.css&quot;</span><br><span class="line">  # 处理 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。</span><br><span class="line">  - &quot;_css/*&quot;</span><br><span class="line">  # 处理 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件</span><br><span class="line">  - &quot;_css/**/*&quot;</span><br><span class="line"></span><br><span class="line">exclude:</span><br><span class="line">  # 不处理 &#x27;source/js/test.js&#x27;</span><br><span class="line">  - &quot;js/test.js&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件</span><br><span class="line">  - &quot;js/*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 中的文件和子目录下的任何文件</span><br><span class="line">  - &quot;js/**/*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 目录下的所有文件名以 &#x27;test&#x27; 开头的文件，但包括其它文件和子目录下的单文件</span><br><span class="line">  - &quot;js/test*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 及其子目录中任何以 &#x27;test&#x27; 开头的文件</span><br><span class="line">  - &quot;js/**/test*&quot;</span><br><span class="line">  # 不要用 exclude 来忽略 &#x27;source/_posts/&#x27; 中的文件。你应该使用 &#x27;skip_render&#x27;，或者在要忽略的文件的文件名之前加一个下划线 &#x27;_&#x27;</span><br><span class="line">  # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。</span><br><span class="line"></span><br><span class="line">ignore:</span><br><span class="line">  # 忽略任何一个名叫 &#x27;foo&#x27; 的文件夹</span><br><span class="line">  - &quot;**/foo&quot;</span><br><span class="line">  # 只忽略 &#x27;themes/&#x27; 下的 &#x27;foo&#x27; 文件夹</span><br><span class="line">  - &quot;**/themes/*/foo&quot;</span><br><span class="line">  # 对 &#x27;themes/&#x27; 目录下的每个文件夹中忽略名叫 &#x27;foo&#x27; 的子文件夹</span><br><span class="line">  - &quot;**/themes/**/foo&quot;</span><br></pre></td></tr></table></figure>

<p>列表中的每一项都必须用单引号或双引号包裹起来。</p>
<p>include 和 exclude 并不适用于 themes&#x2F; 目录下的文件。如果需要忽略 themes&#x2F; 目录下的部分文件或文件夹，可以使用 ignore 或在文件名之前添加下划线 _。</p>
<p><strong>使用代替配置文件</strong></p>
<p>可以在 hexo-cli 中使用 –config 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<p><strong>#用 ‘custom.yml’ 代替 ‘_config.yml’</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server --config custom.yml</span><br></pre></td></tr></table></figure>

<p>**#使用 ‘custom.yml’ 和 ‘custom2.json’，优先使用 ‘custom3.yml’，然后是 ‘custom2.json’<br>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<p>例如，使用 –options 指定了两个自定义配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>

<p>如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 “foo”: “dinosaur”，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。</p>
<p>使用代替主题配置文件</p>
<p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。</p>
<p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p>
<p>配置文件中的 theme_config</p>
<p>该特性自 Hexo 2.8.2 起提供</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#_config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line">theme_config:</span><br><span class="line">  bio: &quot;My awesome bio&quot;</span><br><span class="line">  foo:</span><br><span class="line">    bar: &#x27;a&#x27;</span><br><span class="line">#themes/my-theme/_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独立的 <strong>_config.[theme].yml</strong> 文件</p>
<p>该特性自 Hexo 5.0.0 起提供</p>
<p>独立的主题配置文件应放置于站点根目录下，支持 yml 或 json 格式。需要配置站点 <strong>_config.yml</strong> 文件中的 theme 以供 Hexo 寻找 <strong>_config.[theme].yml</strong> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#_config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line">#_config.my-theme.yml</span><br><span class="line">bio: &quot;My awesome bio&quot;</span><br><span class="line">foo:</span><br><span class="line">  bar: &#x27;a&#x27;</span><br><span class="line">#themes/my-theme/_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 theme_config 的优先级最高，其次是 _config.[theme].yml 文件，最后是位于主题目录下的 _config.yml 文件。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><strong>init</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<p>本命令相当于执行了以下几步：</p>
<p>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。</p>
<p>使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。</p>
<p><strong>new</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义新文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td>文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
<p><strong>generate</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d, –deploy</td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w, –watch</td>
<td>监视文件变动</td>
</tr>
<tr>
<td>-b, –bail</td>
<td>生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td>-f, –force</td>
<td>强制重新生成文件</td>
</tr>
<tr>
<td>-c, –concurrency</td>
<td>最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。</p>
<p>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></p>
<p><strong>-c, –concurrency</strong>	最大同时生成文件的数量，默认无限制<br>该命令可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">publish</span><br><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<p><strong>server</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<p><strong>deploy</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-g, –generate</td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p><strong>render</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-o, –output</td>
<td>设置输出路径</td>
</tr>
</tbody></table>
<p><strong>migrate</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>从其他博客系统 迁移内容。</p>
<p><strong>clean</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<p><strong>list</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>列出网站资料。</p>
<p><strong>version</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>

<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>

<p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>
<h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>

<p>隐藏终端信息。</p>
<p>自定义配置文件的路径</p>
<p><strong>#使用 custom.yml 代替默认的 _config.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server --config custom.yml</span><br></pre></td></tr></table></figure>

<p><strong>#使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。</p>
<p>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<p><strong>#使用 custom.yml 代替默认的 _config.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server --config custom.yml</span><br></pre></td></tr></table></figure>

<p><strong>#使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>

<p>显示 source&#x2F;_drafts 文件夹中的草稿文章。</p>
<h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>

<p>自定义当前工作目录（Current working directory）的路径。</p>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>首先，安装 hexo-migrator-rss 插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-rss --save</span><br></pre></td></tr></table></figure>

<p>插件安装完成后，执行下列命令，从 RSS 迁移所有文章。source 可以是文件路径或网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h3><p>把 _posts 文件夹内的所有文件复制到 source&#x2F;_posts 文件夹，并在 _config.yml 中修改 new_post_name 参数。</p>
<p><strong>new_post_name: :year-:month-:day-:title.md</strong></p>
<h3 id="Octopress"><a href="#Octopress" class="headerlink" title="Octopress"></a>Octopress</h3><p>把 Octopress source&#x2F;_posts 文件夹内的所有文件转移到 Hexo 的 source&#x2F;_posts 文件夹，并修改 _config.yml 中的 new_post_name 参数。</p>
<p><strong>new_post_name: :year-:month-:day-:title.md</strong></p>
<h3 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h3><p>首先，安装 hexo-migrator-wordpress 插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure>

<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。</p>
<p>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo migrate wordpress &lt;source&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见Front-matter中的分类与标签）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。</p>
<h3 id="Joomla"><a href="#Joomla" class="headerlink" title="Joomla"></a>Joomla</h3><p>首先，安装 hexo-migrator-joomla 插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-joomla --save</span><br></pre></td></tr></table></figure>

<p>使用 J2XML 组件导出 Joomla 文章。</p>
<p>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 Joomla 导出的文件路径或网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo migrate joomla &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>
<h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source&#x2F;_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source&#x2F;_drafts</td>
</tr>
</tbody></table>
<h3 id="禁用布局"><a href="#禁用布局" class="headerlink" title="禁用布局"></a>禁用布局</h3><p>如果你不希望一篇文章（post&#x2F;page）使用主题处理，请在它的 front-matter 中设置 layout: false。详情请参考本节。</p>
<h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td>:year</td>
<td>建立的年份，比如， 2015</td>
</tr>
<tr>
<td>:month</td>
<td>建立的月份（有前导零），比如， 04</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立的月份（无前导零），比如， 4</td>
</tr>
<tr>
<td>:day</td>
<td>建立的日期（有前导零），比如， 07</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立的日期（无前导零），比如， 7</td>
</tr>
</tbody></table>
<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，您可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p>
<h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>

<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>文件建立日期</td>
</tr>
</tbody></table>
<h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>
<p>例如，Hexo 默认安装了 hexo-renderer-marked 和 hexo-renderer-ejs，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 hexo-renderer-pug，你甚至可以用 Pug 模板语言书写文章。</p>
<p>只需要将文章的扩展名从 md 改成 ejs，Hexo 就会使用 hexo-renderer-ejs 渲染这个文件，其他格式同理。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法</title>
    <url>/2021/10/09/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>五大常用算法： 分治,动态规划,贪心,回溯,分支限界.</p>
<span id="more"></span>

<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题,直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)等等。<br>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n&#x3D;1时，不需任何计算。n&#x3D;2时，只要作一次比较即可排好序。n&#x3D;3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<h3 id="基本思想及策略"><a href="#基本思想及策略" class="headerlink" title="基本思想及策略"></a>基本思想及策略</h3><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，<code>1&lt;k≤n</code>，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><p>分治法所能解决的问题一般具有以下几个特征：</p>
<ol>
<li><p>该问题的规模缩小到一定的程度就可以容易地解决</p>
</li>
<li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
</li>
<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>
</li>
<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
</li>
</ol>
<blockquote>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法;第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法更好。</p>
</blockquote>
<h3 id="分治法的基本步骤"><a href="#分治法的基本步骤" class="headerlink" title="分治法的基本步骤"></a>分治法的基本步骤</h3><p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li><p>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
</li>
<li><p>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
</li>
<li><p>合并：将各个子问题的解合并为原问题的解。</p>
</li>
</ol>
<p>它的一般的算法设计模式如下：</p>
<p><code>Divide-and-Conquer(P)</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">1.</span> if |P|≤n0</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> then return(ADHOC(P))</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 将P分解为较小的子问题 P1 ,P2 ,...,Pk</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> for i←1 to k</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> T ← MERGE(y1,y2,...,yk) △ 合并子问题</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> return(T)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p>
</blockquote>
<h3 id="分治法的复杂性分析"><a href="#分治法的复杂性分析" class="headerlink" title="分治法的复杂性分析"></a>分治法的复杂性分析</h3><p>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0&#x3D;1，且ADHOC解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用MERGE()将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p>
<p> <code>T（n）= k T(n/m)+f(n)</code></p>
<p>通过迭代法求得方程的解：</p>
<p>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 <strong>mi≤n&lt;mi+1</strong> 时， <strong>T(mi)≤T(n)&lt;T(mi+1)</strong> 。 </p>
<h3 id="可使用分治法求解的一些经典问题"><a href="#可使用分治法求解的一些经典问题" class="headerlink" title="可使用分治法求解的一些经典问题"></a>可使用分治法求解的一些经典问题</h3><ol>
<li>二分搜索</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*定义输出一维数组的函数*/</span><br><span class="line">void print(int array[], int n)&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*定义二分搜索的函数:array,有序序列；n，序列长度；x，要查找的数*/</span><br><span class="line">int binarySearch(int array[], int n, int x)&#123;</span><br><span class="line">    //初始化左右边界</span><br><span class="line">    int left = 0, right = n - 1;</span><br><span class="line">    //当左右边界不重合时</span><br><span class="line">    while (left &lt;= right)&#123;</span><br><span class="line">        //初始化边界的中点</span><br><span class="line">        int middle = (left + right) / 2;</span><br><span class="line">        //判断所查找元素和当前中点元素是否相等，如果相等则返回中点元素所在的位置</span><br><span class="line">        if (x == array[middle])&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x &gt; array[middle])&#123;</span><br><span class="line">            //如果所查找元素大于中点元素，则所查找元素在右部分，则将左边界向右移</span><br><span class="line">            left = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            //说明所查找元素小于中点元素，则所查找元素在左部分，则将右边界向左移</span><br><span class="line">            right = middle - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果找不到，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义待排序的一维数组</span><br><span class="line">    int array[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span><br><span class="line">    //输出原始数组</span><br><span class="line">    cout &lt;&lt; &quot;原始数组是：&quot; &lt;&lt; endl;</span><br><span class="line">    print(array, 10);</span><br><span class="line">    //定义要查找的数</span><br><span class="line">    int number;</span><br><span class="line">    //输入要查找的数</span><br><span class="line">    cout &lt;&lt; &quot;请输入要查找的数：&quot;;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">    //调用二分搜索的函数进行查找</span><br><span class="line">    int location = binarySearch(array, 10, number);</span><br><span class="line">    if (location &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //说明找到了</span><br><span class="line">        cout &lt;&lt; number &lt;&lt; &quot;在该序列中，是第&quot; &lt;&lt; (location + 1) &lt;&lt; &quot;个数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //说明没找到</span><br><span class="line">        cout &lt;&lt; number &lt;&lt; &quot;不在该序列中...&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>汉诺塔</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 定义函数</span><br><span class="line">void moveDisks(int, string, string, string);</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    // 利用 peg 1 ，peg 2 ，peg 3 三个盘位将在 peg1 上数量为n个盘子</span><br><span class="line">    // 移动到 peg 3,前提是，小盘上不能放大盘，一次只能移动一个盘。</span><br><span class="line">    moveDisks (n, &quot;peg 1&quot;, &quot;peg 3&quot;, &quot;peg 2&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;All the disks have been moved!&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void moveDisks(int n, string source, string dest, string temp)</span><br><span class="line">&#123;</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将第 n-1 个磁盘从 source 移动到 temp</span><br><span class="line">        // 使用 dest 作为临时 peg （挂钩）</span><br><span class="line">        moveDisks(n-1, source, temp, dest);</span><br><span class="line">       </span><br><span class="line">        // 将盘子从 source 移动到 dest</span><br><span class="line">        cout &lt;&lt; &quot;Move a disk from &quot; &lt;&lt; source &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; endl;</span><br><span class="line">       </span><br><span class="line">        // 将第 n-1 个磁盘从 temp 移动到 dest</span><br><span class="line">        // 使用 source 作为临时 peg （挂钩）</span><br><span class="line">        moveDisks(n-1, temp, dest, source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>归并排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void merge_sort(int* , int , int , int* );</span><br><span class="line">void merge(int* ,int ,int ,int* );</span><br><span class="line">void merge_sort(int *data, int start, int end, int *result)&#123;</span><br><span class="line">    if(end - start == 1)&#123;   //如果区间中只有两个元素，则对这两个元素进行排序</span><br><span class="line">        if(data[start] &gt; data[end])&#123;</span><br><span class="line">            int temp  = data[start];</span><br><span class="line">            data[start] = data[end];</span><br><span class="line">            data[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(0 == end - start)//如果只有一个元素，则不用排序</span><br><span class="line">        return;</span><br><span class="line">    else&#123;</span><br><span class="line">        //继续划分子区间，分别对左右子区间进行排序</span><br><span class="line">        merge_sort(data,start,(end-start+1)/2+start,result);</span><br><span class="line">        merge_sort(data,(end-start+1)/2+start+1,end,result);</span><br><span class="line">        //开始归并已经排好序的start到end之间的数据</span><br><span class="line">        merge(data,start,end,result);</span><br><span class="line">        //把排序后的区间数据复制到原始数据中去</span><br><span class="line">        for(int i = start;i &lt;= end;++i)</span><br><span class="line">            data[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(int *data,int start,int end,int *result)</span><br><span class="line">&#123;</span><br><span class="line">    int left_length = (end - start + 1) / 2 + 1;//左部分区间的数据元素的个数</span><br><span class="line">    int left_index = start;</span><br><span class="line">    int right_index = start + left_length;</span><br><span class="line">    int result_index = start;</span><br><span class="line">    while(left_index &lt; start + left_length &amp;&amp; right_index &lt; end+1)</span><br><span class="line">    &#123;</span><br><span class="line">        //对分别已经排好序的左区间和右区间进行合并</span><br><span class="line">        if(data[left_index] &lt;= data[right_index])</span><br><span class="line">            result[result_index++] = data[left_index++];</span><br><span class="line">        else</span><br><span class="line">            result[result_index++] = data[right_index++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(left_index &lt; start + left_length)</span><br><span class="line">        result[result_index++] = data[left_index++];</span><br><span class="line">    while(right_index &lt; end+1)</span><br><span class="line">        result[result_index++] = data[right_index++];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int data[] = &#123;9,6,7,22,20,33,16,20&#125;;</span><br><span class="line">    const int length = 8;</span><br><span class="line">    int result[length];</span><br><span class="line">    cout &lt;&lt; &quot;Before sorted:&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i = 0;i &lt; length;++i)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;After sorted:&quot; &lt;&lt; endl;</span><br><span class="line">    merge_sort(data,0,length-1,result);</span><br><span class="line">    for(int i = 0;i &lt; length;++i)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>快速排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void quicksort(int *arr, int l, int r);</span><br><span class="line">void quicksort(int *arr, int l, int r)&#123;</span><br><span class="line">    if (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int i,j,x;</span><br><span class="line">        i = l;</span><br><span class="line">        j = r;</span><br><span class="line">        x = arr[i];</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            while(i &lt; j &amp;&amp; arr[j] &gt; x)</span><br><span class="line">                j--; // 从右向左找第一个小于x的数</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            while(i &lt; j &amp;&amp; arr[i] &lt; x)</span><br><span class="line">                i++; // 从左向右找第一个大于x的数</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = x;</span><br><span class="line">        quicksort(arr, l, i-1); /* 递归调用 */</span><br><span class="line">        quicksort(arr, i+1, r); /* 递归调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[]=&#123;12,21,3,5,10,55,2,24,19&#125;;</span><br><span class="line">    quicksort(a,0,8);</span><br><span class="line">    for(int m=0;m&lt;9;m++)&#123;</span><br><span class="line">        cout&lt;&lt;a[m]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及：<strong>大整数乘法</strong>，<strong>Strassen矩阵乘法</strong>，<strong>棋盘覆盖</strong>，<strong>线性时间选择</strong>，<strong>最接近点对问题</strong>，<strong>循环赛日程表</strong> 等等。</p>
<h3 id="依据分治法设计程序时的思维过程"><a href="#依据分治法设计程序时的思维过程" class="headerlink" title="依据分治法设计程序时的思维过程"></a>依据分治法设计程序时的思维过程</h3><p>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p>
<ol>
<li>一定是先找到最小问题规模时的求解方法</li>
<li>然后考虑随着问题规模增大时的求解方法</li>
<li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li>
</ol>
<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h3 id="动态规划的分类"><a href="#动态规划的分类" class="headerlink" title="动态规划的分类"></a>动态规划的分类</h3><p>大多数动态规划问题都可以被归类成两种类型：优化问题和组合问题</p>
<ol>
<li>优化问题:优化问题就是我们常见的求一个问题最优解（最大值或者最小值）</li>
<li>组合问题:组合问题是希望你弄清楚做某事的数量或者某些事件发生的概率</li>
</ol>
<p><strong>两种不同动态规划解决方案</strong></p>
<ol>
<li>自上而下：即从顶端不断地分解问题，知道你看到的问题已经分解到最小并已得到解决，之后只用返回保存的答案即可</li>
<li>自下而上：你可以直接开始解决较小的子问题，从而获得最小的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。这种方法叫做表格填充法。</li>
</ol>
<h3 id="基本思想与策略"><a href="#基本思想与策略" class="headerlink" title="基本思想与策略"></a>基本思想与策略</h3><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h3 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h3><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<ol>
<li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li>
</ol>
<h3 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a>求解的基本步骤</h3><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<ol>
<li>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</li>
<li>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</li>
<li>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li>
</ol>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p><strong>实际应用中可以按以下几个简化的步骤进行设计：</strong></p>
<ol>
<li>分析最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优解。</li>
<li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。</li>
<li>根据计算最优值时得到的信息，构造问题的最优解。</li>
</ol>
<h3 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a>算法实现的说明</h3><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p><strong>使用动态规划求解问题，最重要的就是确定动态规划三要素：</strong></p>
<ol>
<li>问题的阶段 </li>
<li>每个阶段的状态</li>
<li>从前一个阶段转化到后一个阶段之间的递推关系。</li>
</ol>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<h3 id="常见的动态规划例子"><a href="#常见的动态规划例子" class="headerlink" title="常见的动态规划例子"></a>常见的动态规划例子</h3><ol>
<li>裴波那契数列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long fib(int);</span><br><span class="line">long long fib(int n)&#123;</span><br><span class="line">	if(n&gt;2)</span><br><span class="line">		return fib(n-1)+fib(n-2);</span><br><span class="line">	else</span><br><span class="line">		return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	long long sum;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	sum = fib(n);</span><br><span class="line">	cout &lt;&lt; sum&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把数字翻译成字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成&quot;a&quot;，1翻</span><br><span class="line">** 译成&quot;b&quot;，……，11翻译成&quot;l&quot;，……，25翻译成&quot;z&quot;。一个数字可能有多个翻译。例</span><br><span class="line">** 如12258有5种不同的翻译，它们分别是&quot;bccfi&quot;、&quot;bwfi&quot;、&quot;bczi&quot;、&quot;mcfi&quot;和</span><br><span class="line">*/ &quot;mzi&quot;。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int getTransCount(string,int);</span><br><span class="line">int getTranslation(int);</span><br><span class="line">//递归</span><br><span class="line">int getTransCount(const string&amp; num,int k)&#123;</span><br><span class="line">    int len=num.size();</span><br><span class="line">    //超过长度，只有一种可能</span><br><span class="line">    if(k&gt;=len-1)</span><br><span class="line">        return 1;</span><br><span class="line">    //[k]和[k+1]可以组合成一个字符，有两种方案</span><br><span class="line">    if(k+1&lt;len)&#123;</span><br><span class="line">        int sum=(num[k]-&#x27;0&#x27;)*10+num[k+1]-&#x27;0&#x27;;</span><br><span class="line">        if(sum&gt;9 &amp;&amp; sum&lt;26)</span><br><span class="line">            return getTransCount(num,k+1)+getTransCount(num,k+2);</span><br><span class="line">    &#125;  </span><br><span class="line">    return getTransCount(num,k+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//动态规划</span><br><span class="line">int cnt[70]=&#123;1,1&#125;;//记录用的数组，初始化f(0)=1,f(1)=1</span><br><span class="line">int getTranslation(int num)&#123;</span><br><span class="line">    if(num&lt;0)</span><br><span class="line">        return 0;</span><br><span class="line">    //整数转成字符串</span><br><span class="line">    string numS=to_string(num);</span><br><span class="line">    int numSize=numS.size();</span><br><span class="line">    for(int i=1;i!=numSize;i++)&#123;</span><br><span class="line">        //如果前一个数字是1,和当前数字总能合并翻译</span><br><span class="line">        //f(i)=f(i-1)+f(i-2)</span><br><span class="line">        if(numS[i-1]==&#x27;1&#x27;)</span><br><span class="line">            cnt[i+1]=cnt[i]+cnt[i-1];</span><br><span class="line">        //如果前一个数字是2,那么只有当前数字是0--5才能合并翻译</span><br><span class="line">        else if(numS[i-1]==&#x27;2&#x27;)&#123;</span><br><span class="line">            if(numS[i]&gt;=&#x27;0&#x27;&amp;&amp;numS[i]&lt;=&#x27;5&#x27;)</span><br><span class="line">                cnt[i+1]=cnt[i]+cnt[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //前一个数字是其他数字，都不能合并翻译</span><br><span class="line">        else</span><br><span class="line">            cnt[i+1]=cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[numSize];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int test=12258;</span><br><span class="line">    int count1=getTranslation(test);</span><br><span class="line">    ////</span><br><span class="line">    string numS=to_string(test);</span><br><span class="line">    int k=2;</span><br><span class="line">    int count2=getTransCount(numS,k);</span><br><span class="line">    cout&lt;&lt;count1&lt;&lt;&quot; &quot;&lt;&lt;count2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最佳观光组合<br>买卖股票的最佳时机<br>最大子序和<br>区域和检索-数组不可变<br>按摩师<br>打家劫舍<br>最小化费爬楼梯<br>三步问题<br>猜数字大小</p>
<p>未完，更新中～～～</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>分支限界</tag>
      </tags>
  </entry>
</search>
