---
title: 五大常用算法
date: 2021-10-09 13:35:23
tags:
    - 分治
    - 动态规划
    - 贪心
    - 回溯
    - 分支限界
categories:
    - 算法

---
五大常用算法： 分治,动态规划,贪心,回溯,分支限界.
<!--more -->

# 分治算法

### 基本概念

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题,直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)等等。
任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

### 基本思想及策略

分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

如果原问题可分割成k个子问题，`1<k≤n`，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

### 分治法适用的情况

分治法所能解决的问题一般具有以下几个特征：

1. 该问题的规模缩小到一定的程度就可以容易地解决

2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3. 利用该问题分解出的子问题的解可以合并为该问题的解；

4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法;第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法更好。

### 分治法的基本步骤

分治法在每一层递归上都有三个步骤：

1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

3. 合并：将各个子问题的解合并为原问题的解。

它的一般的算法设计模式如下：

`Divide-and-Conquer(P)`

```markdown

1. if |P|≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)

```

>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。

### 分治法的复杂性分析

一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且ADHOC解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用MERGE()将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：

 `T（n）= k T(n/m)+f(n)`

通过迭代法求得方程的解：

递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 **mi≤n<mi+1** 时， **T(mi)≤T(n)<T(mi+1)** 。 

### 可使用分治法求解的一些经典问题


1. 二分搜索

```
#include<bits/stdc++.h>
using namespace std;

/*定义输出一维数组的函数*/
void print(int array[], int n){
    for (int i = 0; i < n; i++){
        cout << array[i] << " ";
    }
    cout << endl;
}

/*定义二分搜索的函数:array,有序序列；n，序列长度；x，要查找的数*/
int binarySearch(int array[], int n, int x){
    //初始化左右边界
    int left = 0, right = n - 1;
    //当左右边界不重合时
    while (left <= right){
        //初始化边界的中点
        int middle = (left + right) / 2;
        //判断所查找元素和当前中点元素是否相等，如果相等则返回中点元素所在的位置
        if (x == array[middle]){
            return middle;
        }
        else if (x > array[middle]){
            //如果所查找元素大于中点元素，则所查找元素在右部分，则将左边界向右移
            left = middle + 1;
        }
        else{
            //说明所查找元素小于中点元素，则所查找元素在左部分，则将右边界向左移
            right = middle - 1;
        }
    }
    //如果找不到，则返回-1
    return -1;
}
int main()
{
    //定义待排序的一维数组
    int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    //输出原始数组
    cout << "原始数组是：" << endl;
    print(array, 10);
    //定义要查找的数
    int number;
    //输入要查找的数
    cout << "请输入要查找的数：";
    cin >> number;
    //调用二分搜索的函数进行查找
    int location = binarySearch(array, 10, number);
    if (location >= 0)
    {
        //说明找到了
        cout << number << "在该序列中，是第" << (location + 1) << "个数" << endl;
    }
    else
    {
        //说明没找到
        cout << number << "不在该序列中..." << endl;

    }
    return 0;
}
```

2. 汉诺塔

```
#include <bits/stdc++.h>
using namespace std;
// 定义函数
void moveDisks(int, string, string, string);
int main(){
    int n;
    cin>>n;
    // 利用 peg 1 ，peg 2 ，peg 3 三个盘位将在 peg1 上数量为n个盘子
    // 移动到 peg 3,前提是，小盘上不能放大盘，一次只能移动一个盘。
    moveDisks (n, "peg 1", "peg 3", "peg 2");
    cout << "All the disks have been moved!"<<endl;
    return 0;
}
void moveDisks(int n, string source, string dest, string temp)
{
    if (n > 0)
    {
        // 将第 n-1 个磁盘从 source 移动到 temp
        // 使用 dest 作为临时 peg （挂钩）
        moveDisks(n-1, source, temp, dest);
       
        // 将盘子从 source 移动到 dest
        cout << "Move a disk from " << source << " to " << dest << endl;
       
        // 将第 n-1 个磁盘从 temp 移动到 dest
        // 使用 source 作为临时 peg （挂钩）
        moveDisks(n-1, temp, dest, source);
    }
}
```

3. 归并排序

```
#include <bits/stdc++.h>
using namespace std;
void merge_sort(int* , int , int , int* );
void merge(int* ,int ,int ,int* );
void merge_sort(int *data, int start, int end, int *result){
    if(end - start == 1){   //如果区间中只有两个元素，则对这两个元素进行排序
        if(data[start] > data[end]){
            int temp  = data[start];
            data[start] = data[end];
            data[end] = temp;
        }
        return;
    }
    else if(0 == end - start)//如果只有一个元素，则不用排序
        return;
    else{
        //继续划分子区间，分别对左右子区间进行排序
        merge_sort(data,start,(end-start+1)/2+start,result);
        merge_sort(data,(end-start+1)/2+start+1,end,result);
        //开始归并已经排好序的start到end之间的数据
        merge(data,start,end,result);
        //把排序后的区间数据复制到原始数据中去
        for(int i = start;i <= end;++i)
            data[i] = result[i];
    }
}

void merge(int *data,int start,int end,int *result)
{
    int left_length = (end - start + 1) / 2 + 1;//左部分区间的数据元素的个数
    int left_index = start;
    int right_index = start + left_length;
    int result_index = start;
    while(left_index < start + left_length && right_index < end+1)
    {
        //对分别已经排好序的左区间和右区间进行合并
        if(data[left_index] <= data[right_index])
            result[result_index++] = data[left_index++];
        else
            result[result_index++] = data[right_index++];
    }
    while(left_index < start + left_length)
        result[result_index++] = data[left_index++];
    while(right_index < end+1)
        result[result_index++] = data[right_index++];
}
int main()
{
    int data[] = {9,6,7,22,20,33,16,20};
    const int length = 8;
    int result[length];
    cout << "Before sorted:" << endl;
    for(int i = 0;i < length;++i)
        cout << data[i] << "  ";
    cout << endl;
    cout << "After sorted:" << endl;
    merge_sort(data,0,length-1,result);
    for(int i = 0;i < length;++i)
        cout << data[i] << "  ";
    cout << endl;

    return 0;
}

```

4. 快速排序

```
#include <bits/stdc++.h>
using namespace std;
void quicksort(int *arr, int l, int r);
void quicksort(int *arr, int l, int r){
    if (l < r)
    {
        int i,j,x;
        i = l;
        j = r;
        x = arr[i];
        while (i < j)
        {
            while(i < j && arr[j] > x)
                j--; // 从右向左找第一个小于x的数
            if(i < j)
                arr[i++] = arr[j];
            while(i < j && arr[i] < x)
                i++; // 从左向右找第一个大于x的数
            if(i < j)
                arr[j--] = arr[i];
        }
        arr[i] = x;
        quicksort(arr, l, i-1); /* 递归调用 */
        quicksort(arr, i+1, r); /* 递归调用 */
    }
}

int main(){
    int a[]={12,21,3,5,10,55,2,24,19};
    quicksort(a,0,8);
    for(int m=0;m<9;m++){
        cout<<a[m]<<" ";
    }
    return 0;
}
```

以及：**大整数乘法**，**Strassen矩阵乘法**，**棋盘覆盖**，**线性时间选择**，**最接近点对问题**，**循环赛日程表** 等等。

### 依据分治法设计程序时的思维过程

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
1. 一定是先找到最小问题规模时的求解方法
2. 然后考虑随着问题规模增大时的求解方法
3. 找到求解的递归函数式后（各种规模或因子），设计递归程序即可。


# 动态规划算法

### 基本概念

动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

### 动态规划的分类

大多数动态规划问题都可以被归类成两种类型：优化问题和组合问题
1. 优化问题:优化问题就是我们常见的求一个问题最优解（最大值或者最小值）
2. 组合问题:组合问题是希望你弄清楚做某事的数量或者某些事件发生的概率

**两种不同动态规划解决方案**
1. 自上而下：即从顶端不断地分解问题，知道你看到的问题已经分解到最小并已得到解决，之后只用返回保存的答案即可
2. 自下而上：你可以直接开始解决较小的子问题，从而获得最小的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。这种方法叫做表格填充法。

### 基本思想与策略

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

 
### 适用的情况

能采用动态规划求解的问题的一般要具有3个性质：

1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

### 求解的基本步骤

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

1. 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
2. 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
3. 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
4. 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

**实际应用中可以按以下几个简化的步骤进行设计：**

1. 分析最优解的性质，并刻画其结构特征。
2. 递归的定义最优解。
3. 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。
4. 根据计算最优值时得到的信息，构造问题的最优解。

### 算法实现的说明

动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。

**使用动态规划求解问题，最重要的就是确定动态规划三要素：**
1. 问题的阶段 
2. 每个阶段的状态
3. 从前一个阶段转化到后一个阶段之间的递推关系。

递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。

确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

### 常见的动态规划例子

1. 裴波那契数列

```
#include <bits/stdc++.h>
using namespace std;
long long fib(int);
long long fib(int n){
	if(n>2)
		return fib(n-1)+fib(n-2);
	else
		return 1;
}
int main(){
	int n;
	long long sum;
	cin>>n;
	sum = fib(n);
	cout << sum<<endl;
	return 0;
}
```

2. 把数字翻译成字符串

```
/* 题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成"a"，1翻
** 译成"b"，……，11翻译成"l"，……，25翻译成"z"。一个数字可能有多个翻译。例
** 如12258有5种不同的翻译，它们分别是"bccfi"、"bwfi"、"bczi"、"mcfi"和
*/ "mzi"。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。

#include <vector>
#include <bits/stdc++.h>
using namespace std;
int getTransCount(string,int);
int getTranslation(int);
//递归
int getTransCount(const string& num,int k){
    int len=num.size();
    //超过长度，只有一种可能
    if(k>=len-1)
        return 1;
    //[k]和[k+1]可以组合成一个字符，有两种方案
    if(k+1<len){
        int sum=(num[k]-'0')*10+num[k+1]-'0';
        if(sum>9 && sum<26)
            return getTransCount(num,k+1)+getTransCount(num,k+2);
    }  
    return getTransCount(num,k+1);
}

//动态规划
int cnt[70]={1,1};//记录用的数组，初始化f(0)=1,f(1)=1
int getTranslation(int num){
    if(num<0)
        return 0;
    //整数转成字符串
    string numS=to_string(num);
    int numSize=numS.size();
    for(int i=1;i!=numSize;i++){
        //如果前一个数字是1,和当前数字总能合并翻译
        //f(i)=f(i-1)+f(i-2)
        if(numS[i-1]=='1')
            cnt[i+1]=cnt[i]+cnt[i-1];
        //如果前一个数字是2,那么只有当前数字是0--5才能合并翻译
        else if(numS[i-1]=='2'){
            if(numS[i]>='0'&&numS[i]<='5')
                cnt[i+1]=cnt[i]+cnt[i-1];
        }
        //前一个数字是其他数字，都不能合并翻译
        else
            cnt[i+1]=cnt[i];
    }
    return cnt[numSize];
}
int main()
{
    int test=12258;
    int count1=getTranslation(test);
    ////
    string numS=to_string(test);
    int k=2;
    int count2=getTransCount(numS,k);
    cout<<count1<<" "<<count2<<endl;
}
```

最佳观光组合
买卖股票的最佳时机
最大子序和
区域和检索-数组不可变
按摩师
打家劫舍
最小化费爬楼梯
三步问题
猜数字大小

未完，更新中～～～